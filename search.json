[{"title":"树链剖分","url":"/2025/10/20/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","content":"前置知识点\r\nLCA，树形DP，DFS序，线段树\r\n定义\r\n简单来说树链剖分就是将一棵树分成几条链，将树形变成线性从而减少处理难度。\r\n接下来介绍细节的概念\r\n\r\n重儿子：对于每一个非叶子节点，它的儿子中以儿子为根的树子节点数最多的儿子就是它的重儿子\r\n轻儿子：对于每一个非叶子节点，它的非重儿子就是轻儿子\r\n叶子节点没有儿子所以没有重和轻儿子\r\n重边：一个重儿子和他的父亲连接的边被称为重边\r\n轻边：剩下的所有都是轻边\r\n重链：相邻重边连接起来的路径叫重链\r\n对于每一个叶子节点如果它是轻儿子它有一条自己构成的长度为1的链\r\n每一条重链都会以一个轻儿子为起点（如果整条树的根算作轻儿子的话）\r\n那么对于所有要进行的操作只要对于每一个链去操作就好了，所以树链剖分又被叫做重链剖分\r\n\r\n具体做法\r\n首先，第一步dfs1完成预处理\r\n\r\n节点深度\r\n节点的父亲\r\n节点的重儿子编号\r\n每个结点的子树大小。\r\n\r\ninline void dfs(int u,int f,int depth)&#123;\tdep[y]=depth;fa[u]=f;siz[u]=1;\tint mxson=-1;\tfor (int i=0;i&lt;g[u].size();i++)&#123;\t\tint v=g[u][i];\t\tif (v==f) continue;\t\tdfs1(v,u,depth+1);\t\tsiz[u]+=siz[v];\t\tif (siz[v]&gt;mxson)&#123;\t\t\tmxson=siz[v];\t\t\tson[u]=v;\t\t&#125;\t&#125;&#125;\r\n其次，第二步dfs2完成预处理\r\n\r\n节点的新编号（也就是优先处理重儿子，可以保证每一条重链中的节点编号连续）\r\n将每个结点的初始值赋值给新编号\r\n处理每个点所在链的顶端\r\n链接每一条重链\r\n\r\n其实不难发现为什么要和dfs1分开，因为要判断是否是叶子节点并且新序列的求解依赖于对于重儿子的判断\r\ninline void dfs2(int u,int topfa)&#123;\tid[u]=++cnt;w[cnt]=val[u];top[u]=topfa;\tif (!son[u]) return;\tdfs2(son[u],topfa);\tfor (int i=0;i&lt;g[i].size();i++)&#123;\t\tint v=g[u][i];\t\tif (v==fa[u] || v==son[u]) continue;\t\tdfs2(v,v);\t&#125;&#125;\r\n并且发现因为dfs的原因，每一条子树的新编号实际上也是连续的\r\n最后，思考需要完成的任务\r\n\r\n处理两点间路径的点权和\r\n处理以一个节点为根的树总的点权和\r\n修改任一路径上的点权\r\n修改以一个节点为根的树的点权\r\n\r\n路径点权和\r\n这里有点类似于倍增求lca的想法，主要目标是让两个点最终跳到同一条重链上。\r\n设所在链顶端的深度更深的那个点为x点\r\n\r\nres加上x到x所在链顶端的区间点权和\r\nx跳到所在链顶端的父亲\r\n不断执行以上步骤直到x与另外一个节点的所在链顶端相同，也就是处在了同一条链上。\r\n\r\n由于重新编号之后编号连续，所以可以使用线段树维护区间和将单次时间复杂度由O(n)转化为O(log2n)\r\ninline int query_path(int u,int v) &#123;\tint res=0;\twhile (top[u]!=top[v])&#123;\t\tif (dep[top[u]]&lt;dep[top[v]]) swap(u,v);\t\tres=(res+query(1,1,n,id[top[u]],id[u]))%mod;\t\tu=fa[top[u]];\t&#125;\tif (dep[u]&gt;dep[v]) swap(u,v);\tres=(res+query(1,1,n,id[u],id[v]))%mod;\treturn ans;&#125;\r\n子树点权和\r\n由于记录了每个节点的子树大小并且每个子树的编号都是连续的，直接线段树区间查询即可\r\ninline int query_tree(int u)&#123;return query(1,1,n,id[u],id[u]+siz[u]-1);&#125;\r\n修改\r\n那么修改和查询对于树上的查询实际上是一样的\r\n最终总结\r\n线段树就只需要按照新的编号建树就可以了\r\n#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;ctype.h&gt;using namespace std;const int N=100005;int n,m,rt,mod,cnt,dep[N],fa[N],id[N],val[N],w[N],siz[N],son[N],top[N];struct Seg&#123;\tint sum,tag;&#125;tr[N&lt;&lt;2];vector&lt;int&gt; g[N];inline int read()&#123;\tint x=0;char ch=getchar();\twhile (!isdigit(ch)) ch=getchar();\twhile (isdigit(ch))&#123;\t\tx=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);\t\tch=getchar();\t&#125;\treturn x;&#125;inline void dfs1(int u,int f,int depth)&#123;\tdep[u]=depth;fa[u]=f;siz[u]=1;\tint mxson=-1;\tfor (int i=0;i&lt;g[u].size();i++)&#123;\t\tint v=g[u][i];\t\tif (v==f) continue;\t\tdfs1(v,u,depth+1);\t\tsiz[u]+=siz[v];\t\tif (siz[v]&gt;mxson)&#123;\t\t\tmxson=siz[v];\t\t\tson[u]=v;\t\t&#125;\t&#125;&#125;inline void dfs2(int u,int topfa)&#123;\tid[u]=++cnt;w[cnt]=val[u];top[u]=topfa;\tif (!son[u]) return;\tdfs2(son[u],topfa);\tfor (int i=0;i&lt;g[u].size();i++)&#123;\t\tint v=g[u][i];\t\tif (v==fa[u] || v==son[u]) continue;\t\tdfs2(v,v);\t&#125;&#125;inline void pushdown(int now,int l,int r)&#123;\tint mid=l+r&gt;&gt;1,ls=now&lt;&lt;1,rs=now&lt;&lt;1|1;\ttr[ls].tag=(tr[ls].tag+tr[now].tag)%mod;\ttr[rs].tag=(tr[rs].tag+tr[now].tag)%mod;\ttr[ls].sum=(tr[ls].sum+tr[now].tag*(mid-l+1)%mod)%mod;\ttr[rs].sum=(tr[rs].sum+tr[now].tag*(r-mid)%mod)%mod;\ttr[now].tag=0;&#125;inline void Build(int now,int l,int r)&#123;\tif (l==r)&#123;\t\ttr[now].sum=w[l]%mod;\t\treturn;\t&#125;\tint mid=l+r&gt;&gt;1,ls=now&lt;&lt;1,rs=now&lt;&lt;1|1;\tBuild(ls,l,mid);Build(rs,mid+1,r);\ttr[now].sum=(tr[ls].sum+tr[rs].sum)%mod;&#125;inline void update(int now,int l,int r,int s,int t,int w)&#123;\tif (s&lt;=l &amp;&amp; r&lt;=t)&#123;\t\ttr[now].sum=(tr[now].sum+w*(r-l+1)%mod)%mod;\t\ttr[now].tag=(tr[now].tag+w)%mod;\t\treturn;\t&#125;\tif (tr[now].tag &amp;&amp; l!=r) pushdown(now,l,r);\tint mid=l+r&gt;&gt;1,ls=now&lt;&lt;1,rs=now&lt;&lt;1|1;\tif (s&lt;=mid) update(ls,l,mid,s,t,w);\tif (mid&lt;t) update(rs,mid+1,r,s,t,w);\ttr[now].sum=(tr[ls].sum+tr[rs].sum)%mod;&#125;inline int query(int now,int l,int r,int s,int t)&#123;\tif (s&lt;=l &amp;&amp; r&lt;=t) return tr[now].sum;\tif (tr[now].tag &amp;&amp; l!=r) pushdown(now,l,r);\tint mid=l+r&gt;&gt;1,ls=now&lt;&lt;1,rs=now&lt;&lt;1|1,res=0;\tif (s&lt;=mid) res=(res+query(ls,l,mid,s,t))%mod;\tif (mid&lt;t) res=(res+query(rs,mid+1,r,s,t))%mod;\treturn res;&#125;inline int query_path(int u,int v) &#123;\tint res=0;\twhile (top[u]!=top[v])&#123;\t\tif (dep[top[u]]&lt;dep[top[v]]) swap(u,v);\t\tres=(res+query(1,1,n,id[top[u]],id[u]))%mod;\t\tu=fa[top[u]];\t&#125;\tif (dep[u]&gt;dep[v]) swap(u,v);\tres=(res+query(1,1,n,id[u],id[v]))%mod;\treturn res;&#125;inline void plus_path(int u,int v,int w)&#123;\tw%=mod;\twhile (top[u]!=top[v])&#123;\t\tif (dep[top[u]]&lt;dep[top[v]]) swap(u,v);\t\tupdate(1,1,n,id[top[u]],id[u],w);\t\tu=fa[top[u]];\t&#125;\tif (dep[u]&gt;dep[v]) swap(u,v);\tupdate(1,1,n,id[u],id[v],w);&#125;inline int query_tree(int u)&#123;return query(1,1,n,id[u],id[u]+siz[u]-1);&#125;inline void plus_tree(int u,int w)&#123;update(1,1,n,id[u],id[u]+siz[u]-1,w);&#125;int main()&#123;\tn=read();m=read();rt=read();mod=read();\tfor (int i=1;i&lt;=n;i++) val[i]=read();\tfor (int i=1;i&lt;n;i++)&#123;\t\tint x=read(),y=read();\t\tg[x].push_back(y);\t\tg[y].push_back(x);\t&#125;\tdfs1(rt,0,0);\tdfs2(rt,rt);\tBuild(1,1,n);\twhile (m--)&#123;\t\tint opt=read(),x,y,z;\t\tif (opt==1)&#123;\t\t\tx=read();y=read();z=read();\t\t\tplus_path(x,y,z);\t\t&#125;else if (opt==2)&#123;\t\t\tx=read();y=read();\t\t\tprintf(&quot;%d\\n&quot;,query_path(x,y));\t\t&#125;else if (opt==3)&#123;\t\t\tx=read();y=read();\t\t\tplus_tree(x,y);\t\t&#125;else&#123;\t\t\tx=read();\t\t\tprintf(&quot;%d\\n&quot;,query_tree(x));\t\t&#125;\t&#125;\treturn 0;&#125; \r\n\r\n\r\n","categories":["学习"],"tags":["C++","图论","模板","树链剖分"]},{"title":"LCA最近公共祖先","url":"/2025/10/20/LCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","content":"不同方法求LCA的合集\r\n\r\n倍增求LCA\r\n原理上来说就和一般的倍增一样，按照2i，i从大到小依次判断是否跳跃直到找到目标。具体分为一下步骤:\r\n\r\ndfs预处理出所有结点的深度（定一个节点为根，一般是0号或者1号节点）\r\n求出nxt[x][i] (按个人喜好，也可以叫fa[x][i]) 代表x节点向上跳2i之后所在的位置\r\n先使用nxt数组将两个点提升到同一高度（也就是让深的节点先跳）\r\n同一高度后两个节点一起跳，i从大到小循环，只要跳到同一个节点就不跳，不是同一个节点就跳，这样就会发现他们会停止在LCA的下方一层，这个时候两个节点的共同父亲就是要求的LCA\r\n\r\nCode\r\n#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=500005;int n,m,rt,fa[N][30],depth[N];vector&lt;int&gt; g[N];inline void dfs(int u,int f)&#123;    fa[u][0]=f;depth[u]=depth[f]+1;    for (int i=0;i&lt;g[u].size();i++)&#123;        int v=g[u][i];        if (v==f) continue;        dfs(v,u);    &#125;&#125;inline void Init()&#123;    for (int i=1;i&lt;=25;i++)        for (int j=1;j&lt;=n;j++)            fa[j][i]=fa[fa[j][i-1]][i-1];&#125;inline int LCA(int u,int v)&#123;    if (depth[u]&lt;depth[v]) swap(u,v);    for (int i=20;~i;i--) if (depth[fa[u][i]]&gt;=depth[v]) u=fa[u][i];    if (u==v) return u;    for (int i=20;~i;i--) if (fa[u][i]!=fa[v][i])&#123;        u=fa[u][i];        v=fa[v][i];    &#125;    return fa[u][0];&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;rt);    for (int i=1;i&lt;n;i++)&#123;        int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        g[x].push_back(y);        g[y].push_back(x);    &#125;    dfs(rt,0);    Init();    while (m--)&#123;        int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        printf(&quot;%d\\n&quot;,LCA(x,y));    &#125;    return 0;&#125;\r\nTarjan求LCA\r\n主要使用了离线tarjan，并查集和dfs，注意是离线算法！\r\n\r\n将每一个点和要跟它求LCA的点记录下来\r\n遍历这个节点的每个子节点并且进入子节点\r\n将子节点与它自己在并查集中合并\r\n遍历要和它求LCA的节点，如果这个点已经被访问了，这个点在并查集中的祖先就是答案。\r\n\r\n总结来说也就是按照dfn序将节点不断合并，两个节点即将合并在一起时的祖先就是答案。\r\nCode:\r\n#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#define PII make_pairusing namespace std;typedef pair&lt;int,int&gt; PR;const int N=500005;int n,m,rt,ans[N],fa[N];bool vis[N];vector&lt;int&gt; g[N];vector&lt;PR&gt; q[N];inline int find(int x)&#123;    if (x!=fa[x]) fa[x]=find(fa[x]);    return fa[x];&#125;inline void merge(int u,int v)&#123;    int x=find(u),y=find(v);    if (x!=y) fa[x]=y;&#125;inline void tarjan(int u)&#123;    vis[u]=1;    for (int i=0;i&lt;g[u].size();i++)&#123;        int v=g[u][i];        if (vis[v]) continue;        tarjan(v);        merge(v,u);    &#125;    for (int i=0;i&lt;q[u].size();i++)&#123;        int v=q[u][i].first,id=q[u][i].second;        if (vis[v] &amp;&amp; ans[id]==0) ans[id]=find(v);    &#125;&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;rt);    for (int i=1;i&lt;=n;i++) fa[i]=i;    for (int i=1;i&lt;n;i++)&#123;        int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        g[x].push_back(y);        g[y].push_back(x);    &#125;    for (int i=1;i&lt;=m;i++)&#123;        int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        q[x].push_back(PII(y,i));        q[y].push_back(PII(x,i));    &#125;    tarjan(rt);    for (int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]);    return 0;&#125;\r\n后续还有树链剖分求LCA等等，还没学到，先鸽一下\r\n\r\n\r\n","categories":["学习"],"tags":["C++","图论","LCA","模板"]},{"title":"2025.10.19 IELTS reading","url":"/2025/10/19/2025-10-19-IELTS-reading/","content":"\r\n\r\n除了A段，基本所有的中心句集中在1，2句，不然也会在最后一句。\r\nAs far as / As for sth./ In terms of sth. / Speaking of sth.\r\n/When it comes to sth./With respect to sth.\r\n都是可能在转述话题的时候使用的短语。\r\n非谓语动词：不定式、动名词(v-ing)、分词(现在分词+过去分词)\r\n关于动名词：有些动词没有专用的名词，所以这是一种特殊形式，不做谓语\r\n不定式和分词一般做后置定语或状语。\r\nsolely=merely 仅仅\r\nnevertheless=however\r\nstate-of-the-art=advanced\r\ntend to 在阅读中常翻译为”往往”\r\ntaked more gambles 更愿意赌一把，gamble赌注\r\ncommitment投入\r\nas well as = and\r\n注意同义替换\r\n\r\n","categories":["学习"],"tags":["English","IELTS"]},{"title":"k叉哈夫曼树与P2168 [NOI2015] 荷马史诗","url":"/2025/10/14/k%E5%8F%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8EP2168-NOI2015-%E8%8D%B7%E9%A9%AC%E5%8F%B2%E8%AF%97/","content":"题目简介\r\nP2168 [NOI2015]\r\n荷马史诗 - 洛谷\r\n精简版：给出一系列信息和信息出现的次数，求所有信息在k进制下的哈夫曼编码，最终的答案就是构建出哈夫曼树的带权路径长度和最深子节点的深度。\r\n\r\n哈夫曼树\r\n定义\r\n\r\n路径与路径长度：路径就是从书中一个节点到另一个节点的最短路径，长度就是经过点数的个数-1，也就是经过的树的边数。\r\n节点的权：图中某一节点的权值，根据题目而定，本题中就是出现的次数\r\n带权路径长度：从根节点到某节点的路径长度与该节点权的乘积，哈夫曼树中常”某节点”表现为叶子节点。简称为PL。\r\n树的带权路径长度:就是以该节点为根所构成的树的所有叶子结点的带权路径长度之和。简写为WPL。\r\n哈夫曼树往往是所有建树方式中整棵树的带权路径长度最小的。\r\n若给边以权值0~k-1，那么走过路径的编码就是哈夫曼编码，也就是题中所描述的“k进制串”\r\n\r\n构造过程\r\n基于贪心和堆实现。\r\n\r\n所有节点单独成树，形成规模为n的森林\r\n每次选取k个WPL最小的树进行合并，成为虚根的左右子树，新根的WPL就是左右子树的WPL之和，注意该题以及大部分背景下如果有比较细致的要求WPL大的为左子树，小的为右子树。这样权值高，也就是更重要的节点的哈夫曼编码就会靠前，优先被检索到。\r\n不断重复2步骤直到只剩下一棵树。\r\n\r\n但是不难发现，k叉哈夫曼树的情况下，最后一轮2操作时很容易出现只剩下2-k-1棵树的情况，若是这个时候强行合并为x叉(显然x &lt; k)，那么在离根节点最近的地方反而浪费了检索空间，势必一定会造成WPL的增大，因为必然有根节点下接k叉的树优于当前构造的树，解决办法也很简单，就是利用空节点将其他节点挤到更优的地方去。\r\n那么要补充几个空节点呢？回顾以上贪心过程，其实是每次消去k棵树，生成1棵树到堆里，那么相当于每次减少k-1棵树，最后只留下一棵树，也就是总共消去n-1棵树，我们只需要补充空节点直到总数-1能被k-1整除即可。\r\n本题代码实现(利用STL优先队列实现小根堆)\r\n#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;int n,k;long long ans;struct Huffman&#123;    long long val;    int depth;    Huffman()&#123;&#125;    Huffman(long long VAL,int DEPTH): val(VAL),depth(DEPTH)&#123;&#125;    inline bool operator &lt; (const Huffman&amp; x) const&#123;        if (val==x.val) return depth&gt;x.depth;        return val&gt;x.val;    &#125;&#125;;priority_queue&lt;Huffman&gt; q;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    for (int i=1;i&lt;=n;i++)&#123;        long long x;scanf(&quot;%lld&quot;,&amp;x);        q.push(Huffman(x,0));    &#125;    while ((n-1)%(k-1)!=0)&#123;        n++;        q.push(Huffman(0,0));    &#125;    while (n&gt;1)&#123;        Huffman NEW=Huffman(0,0);        for (int i=1;i&lt;=k;i++)&#123;            Huffman now=q.top();            NEW.val+=now.val;            NEW.depth=max(NEW.depth,now.depth);            q.pop();        &#125;        ans+=NEW.val;        n-=(k-1);        NEW.depth++;        q.push(NEW);    &#125;    Huffman rt=q.top();    printf(&quot;%lld\\n%d\\n&quot;,ans,rt.depth);    return 0;&#125;\r\n显然这个代码没有维护具体的哈夫曼树形态，只是满足了该题目的需求维护了根节点和树的价值。具体的形态只要在下面进行贪心的循环中加入对于树的维护即可。\r\n\r\n\r\n","categories":["学习"],"tags":["C++","数据结构","哈夫曼树","堆"]},{"title":"P1312 [NOIP 2011 提高组] Mayan 游戏","url":"/2025/10/11/P1312-NOIP-2011-%E6%8F%90%E9%AB%98%E7%BB%84-Mayan-%E6%B8%B8%E6%88%8F/","content":"题目链接\r\nP1312 [NOIP 2011\r\n提高组] Mayan 游戏 - 洛谷\r\n致命细节错误\r\n思路没啥好说的就是单纯模拟\r\n但是！强调！！！\r\n\r\n所有的在DFS内的操作包括回溯数组在内必须定义成局部变量，不然会造成回溯失败！！然后根本查不出来哪里错了调了三个小时。。。。\r\n具体到代码请看注释\r\n#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int a[10][10],n,ans[10][10];bool flag=0;inline int read()&#123;    int x=0;char ch=getchar();    while (!isdigit(ch)) ch=getchar();    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    return x;&#125;inline bool check()&#123;    for (int i=1;i&lt;=5;i++) if (a[i][1]) return 0;    return 1;&#125;int b[10][10];inline void update()&#123;    memset(b,0,sizeof(b));    for (int i=1;i&lt;=5;i++)&#123;        int cnt=0;        for (int j=1;j&lt;=7;j++) if (a[i][j]) b[i][++cnt]=a[i][j];        for (int j=1;j&lt;=7;j++) a[i][j]=b[i][j];    &#125;&#125;inline bool remove()&#123;    memset(b,0,sizeof(b));    for (int i=1;i&lt;=5;i++)        for (int j=1;j&lt;=7;j++)&#123;            if (!a[i][j]) continue;            if (i&gt;2 &amp;&amp; a[i][j]==a[i-1][j] &amp;&amp; a[i][j]==a[i-2][j])                b[i][j]=b[i-1][j]=b[i-2][j]=1;            if (j&gt;2 &amp;&amp; a[i][j]==a[i][j-1] &amp;&amp; a[i][j]==a[i][j-2])                b[i][j]=b[i][j-1]=b[i][j-2]=1;            &#125;    bool res=0;    for (int i=1;i&lt;=5;i++)        for (int j=1;j&lt;=7;j++) if (b[i][j])&#123;            a[i][j]=0;            res=1;        &#125;    return res;&#125;inline void modify(int x,int y,int k)&#123;    swap(a[x+k][y],a[x][y]);    update();    while (remove()) update();&#125;//int t[10][10]; 就是这里！！！不能定义成全局变量 inline void dfs(int now)&#123;    if (now&gt;n)&#123;        if (check())&#123;            for (int i=1;i&lt;=n;i++) printf(&quot;%d %d %d\\n&quot;,ans[i][0],ans[i][1],ans[i][2]);            flag=1;        &#125;        return;    &#125;    int t[10][10];//必须定义成局部变量以供回溯！不然会出现下一次状态拷贝值在上一个函数被回溯的现象，小细节调试的时候很难发现！以后也是检查重点！     memcpy(t,a,sizeof(a));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for (int i=1;i&lt;=5;i++)        for (int j=1;j&lt;=7;j++)&#123;            if (!a[i][j]) break;            ans[now][0]=i-1;            ans[now][1]=j-1;            if (i&lt;5)&#123;                ans[now][2]=1;                modify(i,j,1);                dfs(now+1);                if (flag) return;                memcpy(a,t,sizeof(t));            &#125;            if (i&gt;1 &amp;&amp; !a[i-1][j])&#123;                ans[now][2]=-1;                modify(i,j,-1);                dfs(now+1);                if (flag) return;                memcpy(a,t,sizeof(t));            &#125;        &#125;&#125;int main()&#123;    n=read();    for (int i=1;i&lt;=5;i++)&#123;        int x=read(),cnt=0;        while (x)&#123;            a[i][++cnt]=x;            x=read();        &#125;    &#125;    dfs(1);    if (!flag) puts(&quot;-1&quot;);    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","DFS","致命细节"]},{"title":"P1074 [NOIP 2009 提高组] 靶形数独","url":"/2025/10/11/P1074-NOIP-2009-%E6%8F%90%E9%AB%98%E7%BB%84-%E9%9D%B6%E5%BD%A2%E6%95%B0%E7%8B%AC/","content":"题目链接\r\nP1074 [NOIP 2009\r\n提高组] 靶形数独 - 洛谷\r\n\r\n做题思路\r\n朴素DFS\r\n对于每一次分数和分块分开判断，把每一个没有填的格子记录下来然后根据没有填的格子进行朴素的搜索。然后能过40%都不错了Emmm.\r\n一些优化（也是打深搜的一些好习惯）\r\n\r\n对于类似需要判断的，若是范围小直接打表获取更快的速度（详见代码）\r\n条件允许的情况下，在做选择的时候直接判断，不要等做完了再判断正确性。\r\n这道题而言可以先搜索未填个数少的行（或者列或者块都行），因为这可以从前端开始限制搜索树，方案的总数是一样的，但是会发现，先搜索未填个数少的判断会少很多，因为很多错误的方案会在搜索树比较前面的部分被剪掉。\r\n\r\n可以看一下优化3加了和没加的对比，差距还是很大的\r\n\r\n然后放上加了所有优化之后的代码\r\n#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const short score[9][9]=&#123;    &#123;6,6,6,6,6,6,6,6,6&#125;,    &#123;6,7,7,7,7,7,7,7,6&#125;,    &#123;6,7,8,8,8,8,8,7,6&#125;,    &#123;6,7,8,9,9,9,8,7,6&#125;,    &#123;6,7,8,9,10,9,8,7,6&#125;,    &#123;6,7,8,9,9,9,8,7,6&#125;,    &#123;6,7,8,8,8,8,8,7,6&#125;,    &#123;6,7,7,7,7,7,7,7,6&#125;,    &#123;6,6,6,6,6,6,6,6,6&#125;&#125;;const short block[9][9]=&#123;    &#123;0,0,0,1,1,1,2,2,2&#125;,    &#123;0,0,0,1,1,1,2,2,2&#125;,    &#123;0,0,0,1,1,1,2,2,2&#125;,    &#123;3,3,3,4,4,4,5,5,5&#125;,    &#123;3,3,3,4,4,4,5,5,5&#125;,    &#123;3,3,3,4,4,4,5,5,5&#125;,    &#123;6,6,6,7,7,7,8,8,8&#125;,    &#123;6,6,6,7,7,7,8,8,8&#125;,    &#123;6,6,6,7,7,7,8,8,8&#125;&#125;;int ans=-1,tot=0,a[9][9],row[9][10],rec[9][10],col[9][10];struct BLANK&#123;    int x,y,z;&#125;b[100];inline void dfs(int now,int S)&#123;    if (now==tot)&#123;        ans=max(ans,S);        return;    &#125;    for (int i=1;i&lt;=9;i++)&#123;        int x=b[now].x,y=b[now].y,z=b[now].z;        if (row[x][i] || col[y][i] || rec[z][i]) continue;        row[x][i]=col[y][i]=rec[z][i]=1;        dfs(now+1,S+score[x][y]*i);        row[x][i]=col[y][i]=rec[z][i]=0;    &#125;&#125;int main()&#123;    int now=0;    for (int i=0;i&lt;9;i++)        for (int j=0;j&lt;9;j++)&#123;            scanf(&quot;%d&quot;,&amp;a[i][j]);            if (a[i][j]!=0)&#123;                now+=score[i][j]*a[i][j];                row[i][a[i][j]]=1;                col[j][a[i][j]]=1;                rec[block[i][j]][a[i][j]]=1;            &#125;else&#123;                b[tot].x=i;                b[tot].y=j;                b[tot++].z=block[i][j];            &#125;        &#125;    dfs(0,now);    printf(&quot;%d\\n&quot;,ans);    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","DFS","奇技淫巧","剪枝"]},{"title":"P2324 [SCOI2005] 骑士精神与IDA*","url":"/2025/10/10/P2324-SCOI2005-%E9%AA%91%E5%A3%AB%E7%B2%BE%E7%A5%9E/","content":"题目链接\r\nP2324 [SCOI2005]\r\n骑士精神 - 洛谷\r\n题目思路\r\nIDA*算法\r\n\r\n与A*算法类似，学名也叫启发式合并，并且融合迭代加深搜索算法。\r\n定义预测步数函数h(x)，那么显然如果当前搜索的状态是step，只要h(x) + step &gt; maxdepth那么一定无法在maxdepth的步数内完成，参考\r\nP5507\r\n机关-认识A* | Xavier_Wang’s Blog中对于状态函数的定义，h(x)是h*(x)\r\n的下界，如果h(x) + step &gt; maxstap\r\n那么h*(x) + step &gt; maxstep一定成立，那么就可以直接进行剪枝操作。\r\n那么对于这道题而言，对应的h(x)就是假设所有黑白棋直接能通过空白块互换，那么现在状态和目标状态所不一样棋子（或者空白）的总数。然后就是常规的迭代加深DFS了。\r\n不知道为什么一开始用getchar会出现神奇的错误，于是吃一堑长一智，以后还是不要用花里胡哨的东西了，cin也挺好用的Emmmm其实是博主太菜了。\r\n#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int goal[5][5]=&#123;    &#123;1,1,1,1,1&#125;,    &#123;0,1,1,1,1&#125;,    &#123;0,0,2,1,1&#125;,    &#123;0,0,0,0,1&#125;,    &#123;0,0,0,0,0&#125;&#125;;const int mx[8]=&#123;1,1,2,2,-1,-1,-2,-2&#125;;const int my[8]=&#123;2,-2,1,-1,2,-2,1,-1&#125;;int a[5][5],t[5][5],depth;bool flag;inline int calc()&#123;    int res=0;    for (int i=0;i&lt;5;i++)        for (int j=0;j&lt;5;j++) res+=(t[i][j]!=goal[i][j]);    return res;&#125;inline void dfs(int now,int x,int y)&#123;    if (now==depth)&#123;        if (calc()==0) flag=1;        return;    &#125;    for (int i=0;i&lt;8;i++)&#123;        int u=x+mx[i],v=y+my[i];        if (u&lt;0 || v&lt;0 || u&gt;4 || v&gt;4) continue;        swap(t[u][v],t[x][y]);        int w=calc();        if (w+now&lt;=depth) dfs(now+1,u,v);        swap(t[u][v],t[x][y]);        if (flag) return;    &#125;&#125;int main()&#123;    ios::sync_with_stdio(0);    cin.tie(0);cout.tie(0);    int T;cin &gt;&gt; T;    while (T--)&#123;        int locx,locy;        char ch;        for (int i=0;i&lt;5;i++)            for (int j=0;j&lt;5;j++)&#123;                cin &gt;&gt; ch;                if (ch==&#x27;*&#x27;)&#123;                    a[i][j]=2;                    locx=i;                    locy=j;                &#125;else a[i][j]=ch-&#x27;0&#x27;;            &#125;        if (calc()==0)&#123;            puts(&quot;0&quot;);            continue;        &#125;        flag=0;        for (depth=1;depth&lt;=15;depth++)&#123;            memcpy(t,a,sizeof(a));            dfs(0,locx,locy);            if (flag)&#123;                printf(&quot;%d\\n&quot;,depth);                break;            &#125;        &#125;        if (!flag) puts(&quot;-1&quot;);    &#125;    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","DFS","奇技淫巧","IDA*"]},{"title":"P5507 机关-认识A*","url":"/2025/10/10/P5507-%E6%9C%BA%E5%85%B3-%E8%AE%A4%E8%AF%86A/","content":"题目链接\r\nP5507 机关 -\r\n洛谷\r\n\r\n题目思路\r\n\r\n双向搜索\r\n这是博主一开始想到的思路，类似于DFS的折半搜索，都是将搜索树变为两头的达到限制搜索树效果的方法，可以节省时间复杂度。由于广度优先搜索的特性，到达一个状态一定是步数少的先到达，那么只需要正反同时搜索，正反相遇那个节点就一定是答案。这个时候只要通过记录类似链表的状态回溯数组就可以还原出答案了。思路比较常规，代码如下:\r\n#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;unordered_map&gt;using namespace std;const int N=(1&lt;&lt;24)+5;int b[20],ans[20],rec[N],fa[N],a[15][4],now=0,now_r,mid;bool vis[N],flag=0;char dir[N];queue&lt;int&gt; q;int main()&#123;    for (int i=0;i&lt;12;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        now|=(x-1)&lt;&lt;(i&lt;&lt;1);        for (int j=0;j&lt;4;j++)&#123;            scanf(&quot;%d&quot;,&amp;x);            a[i][j]=x-1;        &#125;    &#125;    int Start=now;    q.push(now);q.push(0);    vis[now]=vis[0]=1;    dir[now]=1;dir[0]=2;//1表示正向,2表示反向    while (q.size() &amp;&amp; !flag)&#123;        int x=q.front();q.pop();        for (int i=0;i&lt;12;i++)&#123;            now=x;            if (dir[x]==1)&#123;                int i_state=(now&gt;&gt;(i&lt;&lt;1))&amp;3;                int j=a[i][i_state];                int j_state=(now&gt;&gt;(j&lt;&lt;1))&amp;3;                now=now^(i_state&lt;&lt;(i&lt;&lt;1))^(((i_state+1)&amp;3)&lt;&lt;(i&lt;&lt;1));                now=now^(j_state&lt;&lt;(j&lt;&lt;1))^(((j_state+1)&amp;3)&lt;&lt;(j&lt;&lt;1));            &#125;else&#123;                int i_state=(now&gt;&gt;(i&lt;&lt;1))&amp;3;                int j=a[i][(i_state+3)&amp;3];                int j_state=(now&gt;&gt;(j&lt;&lt;1))&amp;3;                now=now^(i_state&lt;&lt;(i&lt;&lt;1))^(((i_state+3)&amp;3)&lt;&lt;(i&lt;&lt;1));                now=now^(j_state&lt;&lt;(j&lt;&lt;1))^(((j_state+3)&amp;3)&lt;&lt;(j&lt;&lt;1));            &#125;            if (vis[now])&#123;                if (dir[now]==dir[x]) continue;                flag=1;mid=i+1;                if (dir[now]==2)&#123;                    now_r=now;                    now=x;                &#125;else now_r=x;                break;            &#125;            q.push(now);            vis[now]=1;            dir[now]=dir[x];            fa[now]=x;            rec[now]=i+1;        &#125;        if (flag) break;    &#125;    int cnt=0;    while (now!=Start)&#123;        b[++cnt]=rec[now];        now=fa[now];    &#125;    for (int i=1;i&lt;=cnt;i++) ans[i]=b[cnt-i+1];    ans[++cnt]=mid;    while (now_r!=0)&#123;        ans[++cnt]=rec[now_r];        now_r=fa[now_r];    &#125;    printf(&quot;%d\\n&quot;,cnt);    for (int i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,ans[i]);    return 0;&#125;\r\nA*算法\r\n这里就是新学到的一个搜索方法，学名叫启发式搜索。\r\n这里使用F*(x) = g(x) + h*(x)表示到达x状态所需要付出的最小代价（在本题中的呈现方式就是步数）其中g(x)表示从初始状态到当前状态付出的最小代价，h*(x)表示从当前状态到最终状态所需要付出的最小代价。显然我们无法对于h*(x)做出完美的预估，但是我们可以使用F(x) = h(x) + g(x)，其中h(x)是估值函数，只需要确保h(x)是h*(x)的下界，在广泛的随机数据下下界较小一般也意味着总体不大，通过这样的想法达到抑制搜索树生长的效果\r\n那么具体到本题中h(x)就表示当前x状态下到最终情况最少需要多少步的估值，也就是每个按钮在不受到牵连的情况下转到1步数之和除以二（因为一次转两个）这样h(x)一定是小于实际情况的，也就是h(x)是下界情况。\r\n代码实现上类似优化后Dijkstra，使用小根堆每次取出下界最小的状态进行搜索，状态转移与双向一致，代码如下:\r\n#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;const int N=1&lt;&lt;24;int a[12][4],step[N],Start=0,fa[N],rec[N],ans[20];bool flag=0;struct gear&#123;    int sta;    double F;    gear()&#123;&#125;    gear(int s): sta(s)&#123;        double sum=0;        for (int i=0;i&lt;12;i++) if ((s&gt;&gt;(i&lt;&lt;1))&amp;3) sum+=4-(s&gt;&gt;(i&lt;&lt;1)&amp;3);        F=step[s]+sum*1.2;    &#125;    inline bool operator &lt; (const gear&amp; x)const&#123;return F&gt;x.F;&#125;    //默认大根堆，比较运算符反向实现小根堆 &#125;;priority_queue&lt;gear&gt; q;int main()&#123;    for (int i=0;i&lt;12;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        Start|=((x-1)&lt;&lt;(i&lt;&lt;1));        for (int j=0;j&lt;4;j++)&#123;            scanf(&quot;%d&quot;,&amp;x);            a[i][j]=x-1;        &#125;    &#125;//    printf(&quot;%d\\n&quot;,Start);    q.push(gear(Start));    step[Start]=0;    while (q.size())&#123;//        printf(&quot;%lf\\n&quot;,q.top().F);        int now=q.top().sta;q.pop();//        printf(&quot;%d\\n&quot;,now);        if (now==0) break;        for (int i=0;i&lt;12;i++)&#123;            int i_state=(now&gt;&gt;(i&lt;&lt;1))&amp;3;            int j=a[i][i_state];            int j_state=(now&gt;&gt;(j&lt;&lt;1))&amp;3;            int nxt=now^(i_state&lt;&lt;(i&lt;&lt;1))^(((i_state+1)&amp;3)&lt;&lt;(i&lt;&lt;1));            nxt=nxt^(j_state&lt;&lt;(j&lt;&lt;1))^(((j_state+1)&amp;3)&lt;&lt;(j&lt;&lt;1));            if (!step[nxt])&#123;                step[nxt]=step[now]+1;                fa[nxt]=now;                rec[nxt]=i+1;                if (nxt==0)&#123;                    flag=1;                    break;                &#125;                q.push(gear(nxt));            &#125;        &#125;        if (flag) break;    &#125;    int cnt=0,now=0;    while (now!=Start)&#123;        ans[++cnt]=rec[now];        now=fa[now];    &#125;    printf(&quot;%d\\n&quot;,cnt);    for (int i=cnt;i;i--) printf(&quot;%d &quot;,ans[i]);    return 0;&#125;\r\n注意上面那个gear（机关）结构体中的构造函数，里面F=step[s]+sum/2;\r\n其中sum/2的系数是可以微调的，在确保h是下界的条件下，系数越大跑的越快，但是要是无法保证是下界就会造成答案错误的情况。\r\n然后博主发现其实可以把两个算法写在一起，更快，但是太懒了还是交给大佬吧\r\n完结撒花，下一篇预告IDA*算法\r\n\r\n\r\n","categories":["学习"],"tags":["C++","奇技淫巧","BFS","A*","双向搜索"]},{"title":"P1379 八数码难题","url":"/2025/10/09/P1379-%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/","content":"题目链接\r\nP1379 八数码难题 -\r\n洛谷\r\n很常规的一道广度优先搜索的题目\r\n但是看到了眼前一亮的写法，直接用数字表示状态，非常新颖，博主一开始只会使用哈希，然后看到了这种使用数字表示状态的写法，直接让实现难度变低了。那么下次是不是可以使用字符串和map来表示状态，大大减少码量。\r\n\r\n代码\r\n#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#include&lt;algorithm&gt; #include&lt;unordered_map&gt;#define int long longusing namespace std;int x,mx[4]=&#123;0,1,0,-1&#125;,my[4]=&#123;1,0,-1,0&#125;,a[4][4];queue&lt;int&gt; q;unordered_map&lt;int,int&gt; mp;signed main()&#123;\tscanf(&quot;%lld&quot;,&amp;x);\twhile (q.size()) q.pop();mp.clear();\tmp[x]=0;\tq.push(x);\twhile (q.size())&#123;\t\tint nx,ny,now=q.front();q.pop();\t\tif (now==123804765) break;\t\tint t=now;\t\tfor (int i=3;i;i--)\t\t\tfor (int j=3;j;j--)&#123;\t\t\t\ta[i][j]=t%10;\t\t\t\tif (a[i][j]==0)&#123;\t\t\t\t\tnx=i;\t\t\t\t\tny=j;\t\t\t\t&#125;\t\t\t\tt/=10;\t\t\t&#125;\t\tfor (int i=0;i&lt;4;i++)&#123;\t\t\tint u=nx+mx[i],v=ny+my[i];\t\t\tif (u&lt;=0 || v&lt;=0 || u&gt;3 || v&gt;3) continue;\t\t\tswap(a[u][v],a[nx][ny]);\t\t\tt=0;\t\t\tfor (int i=1;i&lt;=3;i++)\t\t\t\tfor (int j=1;j&lt;=3;j++) t=(t*10)+a[i][j];\t\t\tif (!mp[t])&#123;\t\t\t\tmp[t]=mp[now]+1;\t\t\t\tq.push(t);\t\t\t&#125;\t\t\tswap(a[u][v],a[nx][ny]);\t\t&#125;\t&#125;\tprintf(&quot;%lld\\n&quot;,mp[123804765]);\treturn 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","奇技淫巧","BFS"]},{"title":"CF525EAnya and Cubes","url":"/2025/10/09/CF525EAnya-and-Cubes/","content":"题目描述\r\nProblem -\r\n525E - Codeforces(原题网站)\r\nCF525E Anya and\r\nCubes - 洛谷(翻译后网站)\r\n这道题也不难，题目描述地蛮清楚的，就是来记录一下学到的一个奇技淫巧\r\n折半搜索\r\n\r\n顾名思义，就是将本来的数据平均分成两半然后进行搜索，适用于此类固定了数列要求求最终某一个值相等的个数的深搜题目，看起来折半没节省很多时间，看看时间复杂度，每次有三种选择，朴素时间复杂度O(3n)，折半之后$O(3^{\\frac{n}{2}})$，带入nmax = 25不难发现节省的时间是巨大的。\r\n只需要先进行前半部分的搜索并且记录下状态，然后进行后半部分的搜索并且进行状态匹配即可。然后就使用STL的神器unordered_map，为什么不用map，因为这里并不强调键和值的有序性，只要起到一个类似桶的作用，u_map的时间复杂度和hash一样是线性的，所以总的时间复杂度不会增加。其实是博主一开始用map怎么都过不了第91个点还以为这道题不是折半搜索\r\n#include&lt;cstdio&gt;#include&lt;unordered_map&gt;using namespace std;const int N=26;int n,k,mid;long long S,a[N],fac[N],ans=0;unordered_map&lt;long long,int&gt; tot[N];inline void dfs_l(int x,int cnt,long long sum)&#123;    if (x&gt;mid)&#123;        tot[cnt][sum]++;        return;    &#125;    dfs_l(x+1,cnt,sum);    if (sum+a[x]&lt;=S) dfs_l(x+1,cnt,sum+a[x]);    if (cnt&lt;k &amp;&amp; a[x]&lt;20 &amp;&amp; sum+fac[a[x]]&lt;=S) dfs_l(x+1,cnt+1,sum+fac[a[x]]);&#125;inline void dfs_r(int x,int cnt,long long sum)&#123;    if (x&gt;n)&#123;        for (int i=0;i&lt;=k-cnt;i++) ans+=tot[i][S-sum];        return;    &#125;    dfs_r(x+1,cnt,sum);    if (sum+a[x]&lt;=S) dfs_r(x+1,cnt,sum+a[x]);    if (cnt&lt;k &amp;&amp; a[x]&lt;20 &amp;&amp; sum+fac[a[x]]&lt;=S) dfs_r(x+1,cnt+1,sum+fac[a[x]]);&#125;signed main()&#123;    scanf(&quot;%d%d%lld&quot;,&amp;n,&amp;k,&amp;S);    fac[0]=1ll;    for (int i=1;i&lt;20;i++) fac[i]=(long long)i*fac[i-1];    for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);    mid=n&gt;&gt;1;    dfs_l(1,0,0);    dfs_r(mid+1,0,0);    printf(&quot;%lld\\n&quot;,ans);    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","DFS","折半搜索","奇技淫巧","STL"]},{"title":"P7562 [JOISC 2021] イベント巡り 2","url":"/2025/10/08/P7562-JOISC-2021-%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E5%B7%A1%E3%82%8A-2/","content":"题目解释\r\nP7562 [JOISC 2021]\r\nイベント巡り 2 (Event Hopping 2) (Day4) - 洛谷\r\n所有的都挺清楚的，就是要注意活动时间的哪个描述，意味着在x时刻结束活动之后是可以赶得上x时刻开始的活动的，那么也就是我们只需要默认活动的时间是[x,y)即可。\r\n\r\n前期解题思路\r\n这里首先使用离散化离散坐标。\r\n然后根据离散后的坐标使用st表预处理出第i个位置之后2j个区间后右端点的最左边的位置。\r\n于是查询query(l, r)就是常规st表思路，从l开始跳st表即可，那么区间的个数也就是(1&lt;&lt;i)。\r\n那么首先query(1,len)如果发现存在的区间个数小于k那么直接输出-1，不然在进行下一步。\r\n奇技淫巧部分\r\n博主学习了一个非常牛逼的数据结构由lxl提出，叫珂朵莉树，老司机树(Old_Driver_Tree,ODT)算了管他叫什么能用就行使用了STL中的set作为核心。思想就是分治，使用一个元素去维护一个区间。比如这道题里就先将{1,len}加入set中，通过重载运算符可以让set的find操作变为返回第一个包含目前查找区间的迭代器。然后就可以像类似BFS的方法快乐分治了，只需要找到当前区间，观测其对于答案的贡献，不符合要求跳过，符合要求将原区间进行分割后擦除原区间，继续循环即可。具体看代码。由于set的查找基于红黑树实现，时间复杂度O(log2n)且常数很小，所以在常规随机数据下表现优异，当然瓶颈在于插入，当块数过于多时，复杂度会退化成O(mn)\r\n#include&lt;set&gt;#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=100005;int nxt[N&lt;&lt;1][19],b[N&lt;&lt;1],n,k;struct seg&#123;    int l,r;    seg()&#123;&#125;    seg(int L,int R): l(L),r(R)&#123;&#125;    inline bool operator &lt; (const seg&amp; x)const&#123;return r&lt;x.l;&#125;&#125;a[N];set&lt;seg&gt; s;inline int read()&#123;    int x=0;char ch=getchar();    while (!isdigit(ch)) ch=getchar();    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    return x;&#125;inline int query(int l,int r)&#123;    int res=0;    for (int i=18;~i;i--)&#123;        if (nxt[l][i]&lt;=r+1)&#123;            l=nxt[l][i];            res+=(1&lt;&lt;i);        &#125;    &#125;    return res;&#125;int main()&#123;    n=read();k=read();    int len=0;    for (int i=1;i&lt;=n;i++)&#123;        a[i].l=read();        a[i].r=read();        b[++len]=a[i].l;b[++len]=a[i].r;    &#125;    sort(b+1,b+len+1);    len=unique(b+1,b+len+1)-b;    memset(nxt,0x3f3f3f,sizeof(nxt));    for (int i=1;i&lt;=n;i++)&#123;        a[i].l=lower_bound(b+1,b+len+1,a[i].l)-b;        a[i].r=lower_bound(b+1,b+len+1,a[i].r)-b;        nxt[a[i].l][0]=a[i].r;    &#125;    for (int i=len;i;i--)&#123;        nxt[i][0]=min(nxt[i][0],nxt[i+1][0]);        for (int j=1;j&lt;19;j++) if (nxt[i][j-1]&lt;=len) nxt[i][j]=min(nxt[i+1][j],nxt[nxt[i][j-1]][j-1]);    &#125;    int sum=query(1,len);    if (sum&lt;k)&#123;        puts(&quot;-1&quot;);        return 0;    &#125;    s.insert(seg(1,len));//    seg now=*s.find(seg(3,4));//    printf(&quot;%d %d\\n&quot;,now.l,now.r);    for (int i=1;i&lt;=n;i++)&#123;        auto it=s.find(seg(a[i].l,a[i].r));        if (it==s.end()) continue;        seg now=*it;        if (now.l&lt;=a[i].l &amp;&amp; a[i].r-1&lt;=now.r)&#123;            int del=query(now.l,a[i].l-1)+query(a[i].r,now.r)-query(now.l,now.r);            if (sum+del&gt;=k-1)&#123;                printf(&quot;%d\\n&quot;,i);                k--;                sum+=del;                s.erase(now);                if (now.l&lt;a[i].l) s.insert(seg(now.l,a[i].l-1));                if (a[i].r&lt;=now.r) s.insert(seg(a[i].r,now.r));            &#125;        &#125;        if (k==0) return 0;    &#125;    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","奇技淫巧","STL","ST表","set","离散化","ODT"]},{"title":"STL之set学习笔记","url":"/2025/10/08/STL%E4%B9%8Bset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"构造\r\nset&lt;int&gt; s1;vector&lt;int&gt; v=&#123;...&#125;;set&lt;int&gt; s(v.begin(),v.end());set&lt;int&gt; s2(s1);//将s1复制到s2中\r\n\r\n一些使用方式\r\n//插入元素s.insert(x);//将权值为x的加入s中作为一个元素(也可以是结构体)//遍历for (auto x:s) printf(&quot;%d &quot;,x);//指针类型set&lt;int&gt;::iterator ptr;//也可以是auto（自动） //查找（如果没有找到返回s.end()） set&lt;int&gt;::iterator ptr=s.find(x);//删除（直接删除权值为x的元素） s.erase(x); //删除(删除指针指向的元素，下面的例子中最终还是删除的x)auto ptr=s.find(x);s.erase(ptr); //可以删除区间s.erase(ptr,s.end());//交换s1.swap(s2);//emptys1.empty();//元素个数s.size();//权值为x的元素个数s.count(x);//返回大于等于x权值的迭代器，大于的迭代器 s.lower_bound(x); s.upper_bound(x);\r\n特性\r\n只有键值，也就是实值，所以传递参数只需要传递实值（迭代器除外）\r\n自带去重不允许重复（但是可以查询该元素个数）\r\n使用迭代器遍历时默认为升序\r\n不允许直接修改键值的行为\r\n\r\n\r\n","categories":["学习"],"tags":["C++","STL","set"]},{"title":"P6648 [CCC 2019] Triangle: The Data Structure","url":"/2025/10/07/P6648-CCC-2019-Triangle-The-Data-Structure/","content":"题目链接\r\nP6648 [CCC 2019]\r\nTriangle: The Data Structure - 洛谷\r\n题面表达的挺清楚的\r\n\r\n思路\r\n依旧ST表，但是转化成二维的了，我觉得类似于差分吧，\r\n一开始想把二维转化为一维去做，后面发现不光空间复杂度炸了，而且这样就只能处理矩形的情况，处理三角形会出错，于是考虑使用二位的st表去更新答案。\r\n依旧是常规的二分思路，那么这里二分边长，观察一个三角形，当使用边长为一半的三角形覆盖它的时候，会出现三个边上的正三角和一个中间的倒三角，那么中间的倒三角怎么处理就是主要问题。语言解释不清楚，详见下图\r\n那么显然就可以被完美覆盖，也就是相当于转移方程对应六个三角形。\r\n那么对于答案的求解也是一样的，也是六个三角形，方法有点类似一维情况下的P1816\r\n忠诚 | Xavier_Wang’s\r\nBlog就是统计头和尾，这样虽然中间会有重合但是能不遗漏地统计完所有区域，注意这里后面三个红色三角形的取值就是相当于把len − 2log2len这段空白分为上下两段，中间是红色三角形，具体见代码。\r\n最后一个问题是空间问题，题目只要求求第k个，可以使用滚动数组解决，于是上代码\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#include&lt;algorithm&gt;using namespace std;int n,k,nxt[3005][3005][2];long long ans=0;inline int read()&#123;\tint x=0;char ch=getchar();\twhile (!isdigit(ch)) ch=getchar();\twhile (isdigit(ch))&#123;\t\tx=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);\t\tch=getchar();\t&#125;\treturn x;&#125;int main()&#123;\tn=read();k=read();\tfor (int i=1;i&lt;=n;i++)\t\tfor (int j=1;j&lt;=i;j++)&#123;\t\t\tint x=read();\t\t\tnxt[i][j][0]=x;\t\t&#125;\tint lmt=log2(k);\tfor (int x=1;x&lt;=lmt;x++)&#123;\t\tbool s1=x&amp;1,s2=s1^1;//IMPORTANT!!!!\t\tint len=1&lt;&lt;x;\t\tfor (int i=1;i+len-1&lt;=n;i++)\t\t\tfor (int j=1;j&lt;=i &amp;&amp; j+len-1&lt;=n;j++)&#123;\t\t\t\tnxt[i][j][s1]=nxt[i][j][s2];\t\t\t\tnxt[i][j][s1]=max(nxt[i][j][s1],nxt[i+(len&gt;&gt;1)][j][s2]);\t\t\t\tnxt[i][j][s1]=max(nxt[i][j][s1],nxt[i+(len&gt;&gt;1)][j+(len&gt;&gt;1)][s2]);\t\t\t\tif (x&gt;1)&#123;\t\t\t\t\tnxt[i][j][s1]=max(nxt[i][j][s1],nxt[i+(len&gt;&gt;2)][j][s2]);\t\t\t\t\tnxt[i][j][s1]=max(nxt[i][j][s1],nxt[i+(len&gt;&gt;2)][j+(len&gt;&gt;2)][s2]);\t\t\t\t\tnxt[i][j][s1]=max(nxt[i][j][s1],nxt[i+(len&gt;&gt;1)][j+(len&gt;&gt;2)][s2]);\t\t\t\t&#125;\t\t\t&#125;\t&#125;\tbool now=lmt&amp;1;\tint len=1&lt;&lt;lmt;\tfor (int i=1;i+k-1&lt;=n;i++)\t\tfor (int j=1;j&lt;=i &amp;&amp; j+k-1&lt;=n;j++)&#123;\t\t\tint u=i+k-1,v=j+k-1,res=0,x=(k-len)&gt;&gt;1;\t\t\tres=max(res,nxt[i][j][now]);\t\t\tres=max(res,nxt[u-len+1][j][now]);\t\t\tres=max(res,nxt[u-len+1][v-len+1][now]);\t\t\tif (lmt&gt;1)&#123;\t\t\t\tres=max(res,nxt[i+x-1][j][now]);\t\t\t\tres=max(res,nxt[i+x-1][j+x-1][now]);\t\t\t\tres=max(res,nxt[u-len+1][j+x-1][now]);\t\t\t&#125;\t\t\tans+=(long long)res;\t\t&#125;\tprintf(&quot;%lld\\n&quot;,ans);\treturn 0;&#125;\r\n这里如果滚动数组想要使用位运算来获得常数上的减小千万要注意，博主就一开始\r\nint\r\ns1=x&amp;1,s2=x1;导致了错误，显然s2=s11，所以高端炫技很容易装逼失败然后导致自己调试半天调试不出来，以后千万要注意，涉及位运算想明白了再写.\r\n再见咯十月七号，国庆只有一天咯。\r\n\r\n\r\n","categories":["学习"],"tags":["C++","ST表","数据结构，贪心"]},{"title":"P1816 忠诚","url":"/2025/10/07/P1816-%E5%BF%A0%E8%AF%9A/","content":"题目概述\r\nP1816 忠诚 -\r\n洛谷\r\n给出一串数列，求区间最小值。\r\n题目思路\r\n由于刚刚学会了ST表，使用ST表进行解决。\r\n\r\n刚开始学会ST表的时候意识到一定要搞清楚他的定义\r\n比如这里就是nxt[i][j]表示第i位开始2j的长度内的最小值，比如j = 0时区间长度为20 = 1也就是此时nxt[i][j]代表本身\r\n那么类似动态规划转移方程就是nxt[i][j] = min(nxt[i][j − 1], nxt[i + 2j − 1][j − 1]\r\n那么答案要求的区间最小值也自然是先求出区间步长k = log2(r − l + 1)\r\n由于是向下取整，那么显然答案分为两个区间，也就是\r\nans = min(nxt[l][k], nxt[r − 2k + 1][k])\r\n下面就是代码了\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#include&lt;algorithm&gt;using namespace std;const int N=100005;int n,m,val[N][20],nxt[N][20];inline int read()&#123;    int x=0;char ch=getchar();    while (!isdigit(ch)) ch=getchar();    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    return x;&#125;int main()&#123;    n=read();m=read();    for (int i=1;i&lt;=n;i++)&#123;        int x=read();        nxt[i][0]=x;    &#125;    for (int i=1;i&lt;20;i++)        for (int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++)            nxt[j][i]=min(nxt[j][i-1],nxt[j+(1&lt;&lt;i-1)][i-1]);    while (m--)&#123;        int x=read(),y=read(),k=log2(y-x+1);        printf(&quot;%d &quot;,min(nxt[x][k],nxt[y-(1&lt;&lt;k)+1][k]));    &#125;    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","数据结构","ST表"]},{"title":"P4155 [SCOI2015] 国旗计划","url":"/2025/10/07/P4155-SCOI2015-%E5%9B%BD%E6%97%97%E8%AE%A1%E5%88%92/","content":"题目传送门\r\nP4155 [SCOI2015]\r\n国旗计划 - 洛谷\r\n题目大意\r\n给出n条线段，环上一共m个点，求在第i条线段必须使用时最少要使用及条线段，数据保证线段不会被另外一条线段包涵。\r\n\r\n解题思路\r\n博主才知道原来这种使用倍增思想的可以解决重复问题的这种数组类的数据结构是ST表Emmm\r\n那么就是先破环成链，然后对于左端点从左到右排序，根据每段线段求出最远的跳跃目标（这里使用贪心思想，因为不会被包涵，所以左端点越远右端点一定越远，使用越远的线段那么使用的条数一定越少）。那么求出了第一次的跳跃目标之后使用ST表将重复查询的时间复杂度由线性转化为O(log2n)那么总体的时间复杂度就是排序和后续查找的O(nlogn)了\r\n#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=200005;int n,m,ans[N],nxt[N&lt;&lt;1][20];struct SOL&#123;int l,r,id;&#125;a[N&lt;&lt;1];inline bool cmp(SOL x,SOL y)&#123;return x.l&lt;y.l;&#125;int main()&#123;\tscanf(&quot;%d%d&quot;,&amp;n,&amp;m);\tfor (int i=1;i&lt;=n;i++)&#123;\t\tint x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\t\ta[i].l=x;\t\tif (x&lt;y) a[i].r=y;else a[i].r=y+m;\t\ta[i].id=i;\t&#125;\tsort(a+1,a+n+1,cmp);\tfor (int i=1;i&lt;=n;i++)&#123;\t\ta[i+n].l=a[i].l+m;\t\ta[i+n].r=a[i].r+m;\t&#125;\tn&lt;&lt;=1;\tfor (int i=1,j=1;i&lt;=n;i++)&#123;\t\twhile (j&lt;=n &amp;&amp; a[j].l&lt;=a[i].r) j++;\t\tnxt[i][0]=j-1;\t&#125;\tfor (int i=1;i&lt;20;i++)\t\tfor (int j=1;j&lt;=n;j++) nxt[j][i]=nxt[nxt[j][i-1]][i-1];\tn&gt;&gt;=1;\tfor (int i=1;i&lt;=n;i++)&#123;\t\tint now=i;\t\tfor (int j=19;~j;j--)&#123;\t\t\tif (nxt[now][j] &amp;&amp; a[nxt[now][j]].r&lt;a[i].l+m)&#123;\t\t\t\tnow=nxt[now][j];\t\t\t\tans[a[i].id]+=(1&lt;&lt;j);\t\t\t&#125;\t\t&#125;\t&#125;\tfor (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]+2);\treturn 0;&#125;\r\n\r\n\r\n","tags":["C++","数据结构","ST表","贪心"]},{"title":"P3509 [POI 2010] ZAB-Frog","url":"/2025/10/06/P3509-POI-2010-ZAB-Frog/","content":"题目链接\r\nP3509 [POI 2010]\r\nZAB-Frog - 洛谷\r\n题目大意\r\n给出n个位置，对于每个位置的下一次会跳跃到距离该位置最近的第k个位置，有相同距离的选左边，询问对于每个位置跳跃m次之后会处在哪个位置。\r\n\r\n解题思路\r\n观察范围:1 ≤ k &lt; n ≤ 106, 1 ≤ m ≤ 1018\r\n首先就是想到了对于m次跳跃可以先处理出一次的然后根据倍增处理出跳跃m位之后的情况\r\n那么对于处理出一次，可以使用单调队列来维护。\r\n并且相比于窗口滑动这类题目更加简单，只需要维护两端的指针就好了。\r\n那么对于每一个节点来说，只有两端的位置可能是下一个，显然远端（或是相同距离的左端）会成为下一个跳跃到的节点。\r\n于是代码就写好了\r\n#include&lt;cstdio&gt;using namespace std;int n,k,nxt[1000001][60];long long m,p[1000005];inline void Init()&#123;    for (int i=1;i&lt;=n;i++)        for (int j=1;j&lt;=59;j++) nxt[i][j]=nxt[nxt[i][j-1]][j-1];&#125;inline int find(int now,long long x)&#123;    for (int i=59;~i;i--)        if (x&gt;=(1ll&lt;&lt;i))&#123;            now=nxt[now][i];            x-=(1&lt;&lt;i);            if (x==0) return now;        &#125;    return now;&#125;int main()&#123;    scanf(&quot;%d%d%lld&quot;,&amp;n,&amp;k,&amp;m);    for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;p[i]);    int l=1,r=k+1;    for (int i=1;i&lt;=n;i++)&#123;        while (r+1&lt;=n &amp;&amp; p[r+1]-p[i]&lt;p[i]-p[l])&#123;            l++;            r++;        &#125;        if (p[i]-p[l]&gt;=p[r]-p[i]) nxt[i][0]=l;        else nxt[i][0]=r;    &#125;    Init();    for (int i=1;i&lt;=n;i++)        printf(&quot;%d &quot;,find(i,m));    printf(&quot;\\n&quot;);    return 0;&#125;\r\n信心满满一波提交！但是！喜提26分\r\n记录详情 - 洛谷 |\r\n计算机科学教育新生态\r\n为什么呢，观察到内存只有125MB并且非常严格，直接导致空间的溢出造成WA和MLE.\r\n于是博主百思不得起解查看了题解。\r\n然后震惊于题解思路，非常巧妙地借鉴了快速幂的思想，使用一样的时间复杂度和优秀的空间复杂度完成了任务。\r\n于是最终版本就是这样\r\n#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N=1000005;int n,k,nxt[N],ans[N],t[N];long long m,p[N];inline void Init(long long x)&#123;    for (int i=1;i&lt;=n;i++) ans[i]=i;    while (x)&#123;        if (x&amp;1) for (int i=1;i&lt;=n;i++) ans[i]=nxt[ans[i]];        memcpy(t,nxt,sizeof(nxt));        for (int i=1;i&lt;=n;i++) nxt[i]=t[t[i]];        x&gt;&gt;=1;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d%lld&quot;,&amp;n,&amp;k,&amp;m);    for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;p[i]);    int l=1,r=k+1;    for (int i=1;i&lt;=n;i++)&#123;        while (r+1&lt;=n &amp;&amp; p[r+1]-p[i]&lt;p[i]-p[l])&#123;            l++;            r++;        &#125;        if (p[i]-p[l]&gt;=p[r]-p[i]) nxt[i]=l;        else nxt[i]=r;    &#125;    Init(m);    for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]);     printf(&quot;\\n&quot;);    return 0;&#125;\r\n再见咯,2025/10/06\r\n\r\n\r\n","categories":["学习"],"tags":["C++","贪心","倍增","单调队列"]},{"title":"P5094 [USACO04OPEN] MooFest G 加强版","url":"/2025/10/06/P5094-USACO04OPEN-MooFest-G-%E5%8A%A0%E5%BC%BA%E7%89%88/","content":"题目链接\r\nP5094 [USACO04OPEN]\r\nMooFest G 加强版 - 洛谷\r\n题面解释的挺清楚的\r\n\r\n首先数据范围显然不能使用O(n2)的暴力，看到了max很自然地想到了排序后根据数值大小插入坐标然后根据一个点左边右边分别求区间和乘上当前位置的权值，单点修改，区间查询，很自然地想到线段树，注意同时维护区间和以及区间个数即可\r\n#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int N=50005;int n,mx,ans;struct code&#123;int sum,cnt;&#125;tr[N&lt;&lt;1];struct COW&#123;int v,x;&#125;a[N];inline bool cmp(COW a,COW b)&#123;return a.v&lt;b.v;&#125;inline int lowbit(int x)&#123;return x&amp;(-x);&#125;inline void insert(int x,int w)&#123;    while (x&lt;=mx)&#123;        tr[x].cnt++;        tr[x].sum+=w;        x+=lowbit(x);    &#125;&#125;inline code query(int x)&#123;    code res;res.cnt=0;res.sum=0;    while (x&gt;0)&#123;        res.cnt+=tr[x].cnt;        res.sum+=tr[x].sum;        x-=lowbit(x);    &#125;    return res;&#125;signed main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for (int i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;a[i].v,&amp;a[i].x),mx=max(mx,a[i].x);    sort(a+1,a+n+1,cmp);    for (int i=1;i&lt;=n;i++)&#123;        int now=a[i].v;        code left=query(a[i].x),right=query(mx);        right.cnt-=left.cnt;right.sum-=left.sum;        ans+=now*(a[i].x*left.cnt-left.sum+right.sum-a[i].x*right.cnt);        insert(a[i].x,a[i].x);    &#125;    printf(&quot;%lld\\n&quot;,ans);    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","数据结构","贪心","树状数组"]},{"title":"树状数组","url":"/2025/10/06/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","content":"模板题目参考\r\nP3374\r\n【模板】树状数组 1 - 洛谷\r\nP3368\r\n【模板】树状数组 2 - 洛谷\r\n区别在于单点修改，区间查询和区间修改，单点查询\r\n\r\n树状数组入门\r\n定义介绍\r\n树状数组只是运用了树结构的思想，但是其实并不是真的是构造树形结构，有点trie树的感觉。\r\n树状数组支持区间和，异或和，乘积和RMQ，朴素的树状数组只支持单点修改。\r\n含义\r\n对于每一个tree[i]实际上他维护了一段区间的信息，而这个区间的长度一般是由lowbit(i)来决定，也就是i转换为二进制之后最后一位”1”出现的位置。根据这个定义我们可以写出\r\nlowbit(x) = x and (−x)注意此处and是与运算的意思。结合复数的二进制编码不难理解。那么各种操作也不难理解了\r\n单点（前缀和）查询\r\ninline int query(int x)&#123;    int res=0;    while (x)&#123;        res+=tr[x];        x-=lowbit(x);    &#125;    return res;&#125;//此处默认求前缀和 \r\n单点修改\r\ninline void modify(int x,int w)&#123;    while (x&lt;=n)&#123;        tr[x]+=w;        x+=lowbit(x);    &#125;&#125;//同样默认前缀和 \r\n那么模板二中的区间修改怎么实现？\r\n不难发现只要求单点修改了，联系到差分思想，只要将原来的所谓单点查询转化为差分数组前缀和，将原来的区间修改转化为对于差分之后数据的单点修改（也就是只改变区间头和区间尾）即可。\r\n然后放上两道模板题目的代码\r\n模板①\r\n#include&lt;cstdio&gt;using namespace std;const int N=500005;int n,m,tr[N&lt;&lt;1];inline int lowbit(int x)&#123;return x&amp;(-x);&#125;inline void plus(int x,int w)&#123;\twhile (x&lt;=n)&#123;\t\ttr[x]+=w;\t\tx+=lowbit(x);\t&#125;&#125;inline int query(int x)&#123;\tint res=0;\twhile (x&gt;0)&#123;\t\tres+=tr[x];\t\tx-=lowbit(x);\t&#125;\treturn res;&#125;int main()&#123;\tscanf(&quot;%d%d&quot;,&amp;n,&amp;m);\tfor (int i=1;i&lt;=n;i++)&#123;\t\tint x;scanf(&quot;%d&quot;,&amp;x);\t\tplus(i,x);\t&#125;\twhile (m--)&#123;\t\tint opt;scanf(&quot;%d&quot;,&amp;opt);\t\tif (opt==1)&#123;\t\t\tint x,k;scanf(&quot;%d%d&quot;,&amp;x,&amp;k);\t\t\tplus(x,k);\t\t&#125;else&#123;\t\t\tint x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\t\t\tprintf(&quot;%d\\n&quot;,query(y)-query(x-1));\t\t&#125;\t&#125;\treturn 0;&#125;\r\n模板②\r\n#include&lt;cstdio&gt;using namespace std;const int N=500005;int n,m,tr[N&lt;&lt;1];inline int lowbit(int x)&#123;return x&amp;(-x);&#125;inline void plus(int x,int w)&#123;\twhile (x&lt;=n)&#123;\t\ttr[x]+=w;\t\tx+=lowbit(x);\t&#125;&#125;inline int query(int x)&#123;\tint res=0;\twhile (x&gt;0)&#123;\t\tres+=tr[x];\t\tx-=lowbit(x);\t&#125;\treturn res;&#125;int main()&#123;\tscanf(&quot;%d%d&quot;,&amp;n,&amp;m);\tint now=0,lst=0;\tfor (int i=1;i&lt;=n;i++)&#123;\t\tscanf(&quot;%d&quot;,&amp;now);\t\tplus(i,now-lst);\t\tlst=now;\t&#125;\twhile (m--)&#123;\t\tint opt;scanf(&quot;%d&quot;,&amp;opt);\t\tif (opt==1)&#123;\t\t\tint x,y,k;scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;k);\t\t\tplus(x,k);\t\t\tplus(y+1,-k);\t\t&#125;else&#123;\t\t\tint x;scanf(&quot;%d&quot;,&amp;x);\t\t\tprintf(&quot;%d\\n&quot;,query(x));\t\t&#125;\t&#125;\treturn 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","模板","数据结构","树状数组"]},{"title":"P6824 「EZEC-4」可乐","url":"/2025/10/06/P6824-%E3%80%8CEZEC-4%E3%80%8D%E5%8F%AF%E4%B9%90/","content":"题目传送门\r\nP6824 「EZEC-4」可乐\r\n- 洛谷\r\n题目描述还是很清晰明了的\r\n思路过程\r\n最近看到异或就下意识思考trie树了，看到数据范围发现O(nlogn)可行。\r\n于是一个思路就出来了，暴力枚举每一个范围内的x，然后跑trie树看看对于这个x来说符合条件的“可乐”有几瓶，取max就好了\r\n\r\n一些百思不得其解的地方\r\n不知道为什么trie树insert和query循环的地方，我使用自己的变量的时候总是会出错，比如我for\r\n(int i=mx……)此时mx是8，但是跳出来答案就是0，但是我for(int\r\ni=8……)答案就是正确的，真的不知道为什么，非常玄学。所以注意\r\n以后不要乱使用全局变量，也不要乱玩前后缀++，–\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=1000005;int n,k,mx,ans,tot=1,a[N],tr[N*20][2],siz[N*20];inline void insert(int x)&#123;    for (int i=20,rt=1;~i;i--)&#123;        bool now=(x&gt;&gt;i)&amp;1;        if (!tr[rt][now]) tr[rt][now]=++tot;        rt=tr[rt][now];siz[rt]++;    &#125;&#125;inline int query(int x)&#123;    int res=0,rt=1;    for (int i=20;~i;i--)&#123;        bool now_k=(k&gt;&gt;i)&amp;1,now=(x&gt;&gt;i)&amp;1;        if (now_k==1)&#123;            res+=siz[tr[rt][now]];            rt=tr[rt][now^1];        &#125;else if (tr[rt][now]) rt=tr[rt][now];        else return res;    &#125;    return res+siz[rt];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    mx=(int)log2(k)+1;    for (int i=1;i&lt;=n;i++)&#123;        scanf(&quot;%d&quot;,&amp;a[i]);        insert(a[i]);        mx=max(mx,(int)log2(a[i])+1);    &#125;    int m=1&lt;&lt;mx;    for (int i=0;i&lt;=m;i++)&#123;        ans=max(ans,query(i));        if (ans==n)&#123;            printf(&quot;%d\\n&quot;,n);            return 0;        &#125;    &#125;    printf(&quot;%d\\n&quot;,ans);    return 0;&#125;\r\n完结★,°:.☆(￣▽￣)/$:.°★ 。\r\n\r\n\r\n","categories":["学习"],"tags":["C++","trie树"]},{"title":"二叉搜索树(BST)及红黑树、splay平衡树学习笔记","url":"/2025/10/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST-%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81splay%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"二叉搜索树Binary Search Tree\r\n定义\r\n是一棵满足中序遍历下节点的权值严格递增的特殊的二叉树.\r\n那么实际上也就是符合下面两个条件：\r\n\r\n左子树的节点小于当前节点\r\n右子树的节点大于当前节点\r\n不存在重复节点\r\n\r\n性质\r\n\r\n每个点的左右子树（如果存在的话）都是BST\r\n当前BST的最小节点一定是最左下的节点\r\n当前BST的最大节点一定是最右下的节点\r\n\r\n\r\n构建和插入节点\r\n从根节点开始，根节点不存在则构建根节点，否则，比较和当前节点的大小，小则往左走，大则往右走，知道发现节点X，发现要插入的值小于X且X没有左儿子，则插入为X的左儿子，要插入的值大于X且X没有右儿子，则插入为X的右儿子。\r\n删除节点\r\n查找需要删除的节点的过程省略（同上）\r\n那么找到以后，分几种情况处理\r\n叶子节点\r\n直接删除即可（将其父亲节点指向它的指针设置为空，权值清零）\r\n只有一边子树的节点\r\n发现也简单，只要将其父亲指向它的节点指向它唯一的儿子即可\r\n有两边子树的节点\r\n引入后继节点的概念，是整棵BST中权值最接近当前节点并且大于当前节点的节点。\r\n这里抛开叶子节点的情况，毕竟叶子节点不可能有两边子树\r\n那么一个结点的后继节点也就是这个节点右子树的最左下节点（不一定是叶子节点），也就是一直向左子树搜索知道不存在左子树为止的节点。\r\n那么删除这种节点的情况就好说了，只要将当前节点替换为他的后继节点即可，思考正确性，由于是本来节点的后继节点，在右子树，所以一定比左儿子大，因为是一路往左走且没有左儿子，所以一定是本来右子树里最小的，也就是删除之后右子树所有节点大于插入节点，符合原性质。\r\n修改节点\r\n先删除后添加即可\r\n以上就是二叉查找树(BST)的最基本知识，那么掌握了BST不难发现当数据构成一条链时，时间复杂度会从平均的log转向线性，也就是整棵树变成了链表。所以这时候就可以进一步加强使用自平衡二叉搜索树，也就是平衡树\r\n平衡树\r\n常用的平衡树（也是我要向学完的）是红黑树，splay，treap-旋转/非旋转。其中红黑树效率很高，splay是比赛中最常用的，因为码量不算非常大的情况下支持可持久化，合并，treap码量相对较小\r\n，但是和splay一样速度较慢。\r\n红黑树\r\n值得一提的是STL中的map和set就是使用红黑树实现的\r\n性质\r\n\r\n节点有两种颜色（原作者喜欢红色和黑色）\r\n根节点是黑色的\r\n所有叶子节点都是黑色的\r\n每个红色的节点一定有两个黑色的子节点\r\n从每个叶子到根的所有路径上都不能有两个连续的红色节点\r\n从任何节点到每个叶子的所有简单路径都包含相同数目的黑色节点（这里简称黑高）\r\n\r\n在以上条件的束缚下，路径最长的情况下红色节点数量=黑色节点数量，路径长度为两倍黑色节点数量，也就是最短路径的两倍，也就是能保证时间复杂度始终保持在log级别，二叉树不会退化成链表\r\n旋转\r\n在几乎所有的平衡树中都很重要的操作。\r\n分为左旋转和右旋转，左旋转指的是将某个节点旋转为它右孩子的左孩子，右旋转指的是将某个节点旋转为它左孩子的右孩子，不难发现两个旋转是互逆的操作。\r\n那么以右旋为例，说明如何完成旋转操作，这里假设当前节点是RT,其左儿子是X:\r\n\r\n将RT的左孩子指针指向X的右孩子\r\n将X的右孩子引用指向RT，完成旋转\r\n\r\n不难发现两个旋转都不会对树的性质产生破坏。\r\n在学习的时候发现实现过程没有想象中那么变态哈哈哈哈。\r\n插入\r\n首先参考二叉搜索树，前期过程基本相似，但插入后需要进行调整。\r\n假设当前节点now，父亲节点fa，祖父节点g，叔叔节点u（由于是二叉树所以最多只有一个叔叔节点），会有五种情况\r\n新节点是根节点\r\n直接插入，注意now颜色是黑色\r\nfa是黑色\r\nnow颜色是红色，其他的无需调整\r\nfa是红色，u是红色\r\nnow是红色，将fa和u染为黑色，G染为红色，注意到G的父亲可能是红色，所以需要递归向上染色知道不出现连续的两个红色节点。\r\nfa是红色，u是黑色，now是左孩子\r\n那么G一定是黑色，此时对G进行右旋，调整fa和g的位置然后互换颜色，也就是G变红，fa变黑。\r\nfa是红色，u是黑色，now是右孩子\r\n对fa进行左旋，然后fa变成了now，now变成了fa并且此时now一定是左孩子，那么之后的处理同上即可。\r\n删除\r\n依旧一样，前面步骤同普通BST。\r\n而复杂的，依旧是对于颜色红黑变换的处理问题。\r\n可以观察到由于是对后继原来的位置进行删除操作，那么这个时候被删除的那个位置只存在右子树。\r\n一下是对情况的分类，为了方便说明，这里将当前节点设为now，父亲节点为fa，祖父节点为g，叔叔节点为u，孩子节点为k，兄弟节点bro，bro左孩子节点bl，右孩子节点br。\r\n注意这里fa和now之间本来的节点已经被删除，now现在是顶替上去的那一位。\r\n被删除的是红色（再下面的情况默认被删除的是黑色）\r\n和BST一致操作即可\r\nk是红色（再下面情况默认now和k都是黑色）\r\n只需要将k染色为黑色即可\r\nk是整棵树新的根\r\n那么实际上已经完成了删除操作\r\nfa是红色，bro和bro的孩子是黑色\r\n只需要交换fa和bro的颜色即可。\r\nbro是黑色，bl红色，br黑色，fa无所谓，now是fa的左孩子\r\n对bro进行右旋操作，互换bro和bl的颜色，将树调换成了下一种情况的样子，继续讨论\r\nbro是黑色，br红色，fa无所谓，now是fa的左孩子\r\n对fa进行左旋，互换fa和bro的颜色，将br变为黑色\r\nbro为红色，其他为黑\r\n对fa进行左旋，调换fa和bro的颜色，但是修改仍未完成，但是我们将这种情况转化为了上述情况之一。\r\n代码实现\r\n看看主播什么时候能根据算法导论和维基百科搓出来\r\n主播放弃了，目前的代码是这样的\r\n目前的删除环节仍然存在一定的问题。\r\n#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;typedef enum&#123;RED,BLACK&#125;COLOR;typedef struct RBnode&#123;    int val,cnt;    struct RBnode* lkid;    struct RBnode* rkid;    struct RBnode* fa;    COLOR color;&#125;RBnode;//建点 typedef struct &#123;    struct RBnode* root;&#125;RBtree;//建树 inline RBnode* Init()&#123;//新创建一个节点     RBnode* now= (RBnode*)malloc(sizeof(RBnode));    now-&gt;color=RED;    now-&gt;lkid=NULL;    now-&gt;rkid=NULL;    now-&gt;fa=NULL;    now-&gt;cnt=1;    return now;&#125;inline RBnode* Left_Rotate(RBnode* now)&#123;    RBnode* father=now-&gt;fa;    RBnode* grand=father-&gt;fa;    father-&gt;rkid=now-&gt;lkid;    if (father-&gt;rkid!=NULL) father-&gt;rkid-&gt;fa=father;    now-&gt;lkid=father;    father-&gt;fa=now;    grand-&gt;lkid=now;    now-&gt;fa=grand;    return now;&#125;inline RBnode* Right_Rotate(RBnode* now)&#123;    RBnode* father=now-&gt;fa;    RBnode* grand=father-&gt;fa;    father-&gt;lkid=now-&gt;rkid;    if (father-&gt;lkid!=NULL) father-&gt;lkid-&gt;fa=father;    now-&gt;rkid=father;    father-&gt;fa=now;    grand-&gt;rkid=now;    now-&gt;fa=grand;    return now;&#125;inline void insert_adjust(RBtree* ptree,RBnode* now)&#123;    //虽然失衡才进入，但是还是特判是否失衡    if (now-&gt;fa!=NULL &amp;&amp; now-&gt;fa-&gt;color==BLACK) return;    //只有根节点，染黑即可    if (now-&gt;fa==NULL)&#123;        now-&gt;color=BLACK;        return;    &#125;     //不是root    RBnode* father=now-&gt;fa;    RBnode* grand=father-&gt;fa;    RBnode* uncle;    if (grand-&gt;lkid==father) uncle=grand-&gt;rkid;    else uncle=grand-&gt;lkid;    //uncle是红色，叔父爷变色，调整为其他情况    if (uncle!=NULL &amp;&amp; uncle-&gt;color==RED)&#123;        uncle-&gt;color=BLACK;        father-&gt;color=BLACK;        grand-&gt;color=RED;        insert_adjust(ptree,grand);        return;    &#125;    //叔叔是黑色或空    if (grand-&gt;lkid==father)&#123;        if (father-&gt;lkid==now)&#123;//LL            father-&gt;color=BLACK;            grand-&gt;color=RED;            RBnode* great=grand-&gt;fa;            RBnode* ptr=Right_Rotate(now);            //获取太爷，右旋             if (great==NULL)&#123;                ptree-&gt;root=ptr;                ptr-&gt;fa=NULL;                return;            &#125;else&#123;                if (ptr-&gt;val &lt; great-&gt;val) great-&gt;lkid=ptr;                else great-&gt;rkid=ptr;                ptr-&gt;fa=great;            &#125;            return;        &#125;else&#123;//LR            //左旋后处理冲突             father-&gt;rkid=now-&gt;lkid;             if (father-&gt;rkid!=NULL) father-&gt;rkid-&gt;fa=father;             now-&gt;lkid=father;             father-&gt;fa=now;             grand-&gt;lkid=now;             now-&gt;fa=grand;             //变色然后右旋             grand-&gt;color=RED;             now-&gt;color=BLACK;             RBnode* great=grand-&gt;fa;             RBnode* ptr=Right_Rotate(father);             if (great==NULL)&#123;                 ptree-&gt;root=ptr;                 ptr-&gt;fa=NULL;                 return;             &#125;else&#123;                 if (ptr-&gt;val &lt; great-&gt;val) great-&gt;lkid=ptr;                 else great-&gt;rkid=ptr;                 ptr-&gt;fa=great;             &#125;             return;        &#125;    &#125;    if (grand-&gt;rkid==father)&#123;//R        if (father-&gt;rkid==now)&#123;//RR            father-&gt;color=BLACK;            grand-&gt;color=RED;            RBnode* great=grand-&gt;fa;            RBnode* ptr=Left_Rotate(now);            if (great==NULL)&#123;                ptree-&gt;root=ptr;                ptr-&gt;fa=NULL;                return;            &#125;else&#123;                 if (ptr-&gt;val &lt; great-&gt;val) great-&gt;lkid=ptr;                 else great-&gt;rkid=ptr;                 ptr-&gt;fa=great;            &#125;            return;        &#125;else&#123;//RL            father-&gt;lkid=now-&gt;rkid;            if (father-&gt;lkid!=NULL) father-&gt;lkid-&gt;fa=father;            now-&gt;rkid=father;            father-&gt;fa=now;            grand-&gt;rkid=now;            now-&gt;fa=grand;            grand-&gt;color=RED;            now-&gt;color=BLACK;            RBnode* great=grand-&gt;fa;            RBnode* ptr=Left_Rotate(father);            if (great==NULL)&#123;                ptree-&gt;root=ptr;                ptr-&gt;fa=NULL;                return;            &#125;else&#123;                 if (ptr-&gt;val &lt; great-&gt;val) great-&gt;lkid=ptr;                 else great-&gt;rkid=ptr;                 ptr-&gt;fa=great;            &#125;            return;        &#125;    &#125;&#125;inline RBnode* Search(RBtree* ptree,int val)&#123;    RBnode* p=ptree-&gt;root;    while (p!=NULL &amp;&amp; p-&gt;val!=val)&#123;        if (val &lt; p-&gt;val) p=p-&gt;lkid;        else p=p-&gt;rkid;    &#125;    return p;&#125;inline RBnode* search_front(RBtree* ptree,int val)&#123;    RBnode* p=ptree-&gt;root;    while (p!=NULL)&#123;        if (val &lt;= p-&gt;val) p=p-&gt;lkid;        else p=p-&gt;rkid;    &#125;    return p;&#125;inline RBnode* search_next(RBtree* ptree,int val)&#123;    RBnode* p=ptree-&gt;root;    while (p!=NULL)&#123;        if (val &lt; p-&gt;val) p=p-&gt;lkid;        else p=p-&gt;rkid;    &#125;    return p;&#125;inline void delete_adjust(RBtree* ptree,RBnode* node,bool tag)&#123;    //1.申请多个指针分别用于指向其父节点和兄弟节点以及自己的孩子节点    RBnode* father = node-&gt;fa;    RBnode* sibling = NULL;    RBnode* child = node-&gt;lkid != NULL ? node-&gt;lkid : node-&gt;rkid;//node节点自身的孩子    //2.分情况处理    //待删除节点只有左孩子/只有右孩子    if (tag &amp;&amp; (node-&gt;lkid != NULL || node-&gt;rkid != NULL))&#123;        //若待删除节点的父节点不存在，说明当前单分支节点是根节点        if (father == NULL)&#123;            //让辅助节点抓住它的儿子            ptree-&gt;root = child;        &#125;        else//这个节点不是根节点，那就让它爸来接收它的儿子        &#123;            if (child-&gt;val &lt; father-&gt;val)                father-&gt;lkid = child;            else                father-&gt;rkid = child;        &#125;        child-&gt;fa = father;        child-&gt;color = BLACK;        free(node);        return;    &#125;    else//零分支：此时待删除节点没有孩子    &#123;        if (tag &amp;&amp; (father == NULL))//如果待删除节点没有孩子，且它爸也不在，则无需判断颜色，直接删除        &#123;            ptree-&gt;root = NULL;            free(node);            return;        &#125;        else//它爸在的话，要判断当前没有孩子的节点的颜色了        &#123;            if (tag &amp;&amp; (node-&gt;color == RED))//当前待删除节点node颜色是红色             &#123;                //别忘了，让抓着待删除节点的父节点的相应的孩子指针指向NULL                if (father-&gt;lkid == node)                    father-&gt;lkid = NULL;                else                    father-&gt;rkid = NULL;                //释放当前待删除节点，无需调整                free(node);                return;            &#125;            else//待删除节点没有孩子，但是有双亲，且颜色是黑色             &#123;                //申请一个指针sibling用来指向其兄弟节点                sibling = (node == father-&gt;lkid) ? father-&gt;rkid : father-&gt;lkid;                RBnode* grandfather = father-&gt;fa;//有可能为NULL，它爷爷是有可能不存在的                if (sibling-&gt;color == RED)//兄弟节点是红色                &#123;                    //父兄变色                    sibling-&gt;color = BLACK;                    father-&gt;color = RED;                    //当前的父节点朝着待删除节点(双黑节点)一侧进行单旋                    RBnode* ptr = father-&gt;lkid == node ? Left_Rotate(sibling-&gt;rkid) : Right_Rotate(sibling-&gt;lkid);                    //此时，根据grandfather的存在与否，来接收旋转之后的返回值                    if (grandfather == NULL)                    &#123;                        ptree-&gt;root = ptr;                    &#125;                    else                    &#123;                        if (ptr-&gt;val &lt; grandfather-&gt;val)                            grandfather-&gt;lkid = ptr;                        else                            grandfather-&gt;rkid = ptr;                    &#125;                    ptr-&gt;fa = grandfather;                    //此时，待删除节点出现新的兄弟节点，重新进行逻辑判断                    delete_adjust(ptree, node, tag);//bug 第二个参数有可能是需要删除，有可能是不需要删的 //******                    return;                &#125;                else//兄弟节点是黑色                &#123;                    //此时情况下，兄弟节点是黑色，不管有没有红色孩子，当前待删除节点后续都不                    //再需要它了，所以此时可以提前把它释放带哦                    if (tag)                    &#123;                        if (father-&gt;lkid == node)                            father-&gt;lkid = NULL;                        else                            father-&gt;rkid = NULL;                        free(node);                    &#125;                    //这种情况下，再分兄弟节点有没有红孩                    RBnode* redchild = NULL;                    if (sibling-&gt;lkid != NULL &amp;&amp; sibling-&gt;lkid-&gt;color == RED)                    &#123;                        redchild = sibling-&gt;lkid;                    &#125;                    else if (sibling-&gt;rkid != NULL &amp;&amp; sibling-&gt;rkid-&gt;color == RED)                    &#123;                        redchild = sibling-&gt;rkid;                    &#125;                    else                    &#123;                        redchild = NULL;                    &#125;                    //判断redchild是否是NULL                    //兄弟没有一个红孩                    if (redchild == NULL)                    &#123;                        //兄弟变红                        sibling-&gt;color = RED;                        //双黑上移，双黑节点移动到父节点位置                        if (father-&gt;fa == NULL || father-&gt;color == RED)                        &#123;                            father-&gt;color = BLACK;                            return;                        &#125;                        //不然双黑上移：遇到的节点不是根节点，且是黑色                        delete_adjust(ptree, father, false);                        return;                    &#125;                    else//至少有一个红孩                    &#123;                        //判断兄弟，兄弟他爸，兄弟红色孩子三者型号，调用对应旋转                        if (father-&gt;lkid == sibling)//L                        &#123;                            if (sibling-&gt;lkid == redchild)//LL  // bug 两个等于号又写成一个等于号了                             &#123;                                //先变色，r变s，s变p，p变黑                                redchild-&gt;color = sibling-&gt;color;                                sibling-&gt;color = father-&gt;color;                                father-&gt;color = BLACK;                                //需要单右旋，旋转点是father，绕着兄弟节点转(旋转中心点是sibling)                                RBnode* grandfather = father-&gt;fa;                                RBnode* ptr = Right_Rotate(redchild);                                if (grandfather == NULL)                                &#123;                                    ptree-&gt;root = ptr;                                    ptr-&gt;fa = NULL;                                &#125;                                else                                &#123;                                    if (ptr-&gt;val &lt; grandfather-&gt;val)                                        grandfather-&gt;lkid = ptr;                                    else                                        grandfather-&gt;rkid = ptr;                                    ptr-&gt;fa = grandfather;                                &#125;                                return;                            &#125;                            else//LR                            &#123;                                //先变色，r变p，p变黑                                redchild-&gt;color = father-&gt;color;                                father-&gt;color = BLACK;                                //先左旋                                //先处理冲突节点                                sibling-&gt;rkid = redchild-&gt;lkid;                                if (sibling-&gt;rkid != NULL)                                &#123;                                    sibling-&gt;rkid-&gt;fa = sibling;                                &#125;                                redchild-&gt;lkid = sibling;                                sibling-&gt;fa = redchild;                                father-&gt;lkid = redchild;                                redchild-&gt;fa = father;                                //再右旋                                RBnode* grandfather = father-&gt;fa;                                RBnode* ptr = Right_Rotate(sibling);                                if (grandfather == NULL)                                &#123;                                    ptree-&gt;root = ptr;                                    ptr-&gt;fa = NULL;                                &#125;                                else                                &#123;                                    if (ptr-&gt;val &lt; grandfather-&gt;val)                                        grandfather-&gt;lkid = ptr;                                    else                                        grandfather-&gt;rkid = ptr;                                    ptr-&gt;fa = grandfather;                                &#125;                                return;                            &#125;                        &#125;                        if (father-&gt;rkid == sibling)//R                        &#123;                            if (sibling-&gt;rkid != NULL &amp;&amp; sibling-&gt;rkid-&gt;color == RED)//RR                            &#123;                                redchild = sibling-&gt;rkid;                                //先变色 r变s，s变r，p变黑                                redchild-&gt;color = sibling-&gt;color;                                sibling-&gt;color = father-&gt;color;                                father-&gt;color = BLACK;                                //单左旋                                RBnode* grandfather = father-&gt;fa;                                RBnode* ptr = Left_Rotate(redchild);                                if (grandfather == NULL)                                &#123;                                    ptree-&gt;root = ptr;                                    ptr-&gt;fa = NULL;                                &#125;                                else                                &#123;                                    if (ptr-&gt;val &lt; grandfather-&gt;val)                                        grandfather-&gt;lkid = ptr;                                    else                                        grandfather-&gt;rkid = ptr;                                    ptr-&gt;fa = grandfather;                                &#125;                                return;                            &#125;                            else//RL                            &#123;                                //先变色 r变s，p变黑                                redchild-&gt;color = father-&gt;color;                                father-&gt;color = BLACK;                                //先右旋                                //先处理冲突节点                                sibling-&gt;lkid = redchild-&gt;rkid;                                if (sibling-&gt;lkid != NULL)                                &#123;                                    sibling-&gt;lkid-&gt;fa = sibling;                                &#125;                                redchild-&gt;rkid = sibling;                                sibling-&gt;fa = redchild;                                father-&gt;rkid = redchild;                                redchild-&gt;fa = father;                                //再左旋                                RBnode* grandfather = father-&gt;fa;                                RBnode* ptr = Left_Rotate(sibling);                                if (grandfather == NULL)                                &#123;                                    ptree-&gt;root = ptr;                                    ptr-&gt;fa = NULL;                                &#125;                                else                                &#123;                                    if (ptr-&gt;val &lt; grandfather-&gt;val)                                        grandfather-&gt;lkid = ptr;                                    else                                        grandfather-&gt;rkid = ptr;                                    ptr-&gt;fa = grandfather;                                &#125;                                return;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125; inline void Delete(RBtree* ptree,int val)&#123;    RBnode* now=Search(ptree,val);    now-&gt;val=now-&gt;val-1;    if (now-&gt;val!=0) return;    if (now-&gt;lkid==NULL &amp;&amp; now-&gt;rkid==NULL) delete_adjust(ptree,now,1);    RBnode* Next=search_next(ptree,val);    RBnode* father=now-&gt;fa;    if (now==father-&gt;lkid)&#123;        father-&gt;lkid=Next;        if (Next-&gt;fa-&gt;lkid==Next)&#123;            Next-&gt;fa-&gt;lkid=Next-&gt;rkid;            Next-&gt;rkid-&gt;fa=Next-&gt;fa;        &#125;else&#123;            Next-&gt;fa-&gt;rkid=Next-&gt;rkid;            Next-&gt;rkid-&gt;fa=Next-&gt;fa;        &#125;        Next-&gt;fa=father;    &#125;else&#123;        father-&gt;rkid=Next;        if (Next-&gt;fa-&gt;lkid==Next)&#123;            Next-&gt;fa-&gt;lkid=Next-&gt;rkid;            Next-&gt;rkid-&gt;fa=Next-&gt;fa;        &#125;else&#123;            Next-&gt;fa-&gt;rkid=Next-&gt;rkid;            Next-&gt;rkid-&gt;fa=Next-&gt;fa;        &#125;        Next-&gt;fa=father;    &#125;    free(now);    delete_adjust(ptree,Next,1);&#125;inline void insert(RBtree* ptree,int val)&#123;//插入一个节点     RBnode* now=Init();    now-&gt;val=val;    RBnode* p=ptree-&gt;root;    RBnode* pp=NULL;    if (p==NULL)&#123;//空树直接建根         ptree-&gt;root=now;        now-&gt;color=BLACK;        return;    &#125;    while (p!=NULL &amp;&amp; p-&gt;val!=val)&#123;        pp=p;        if (val &lt; p-&gt;val) p=p-&gt;lkid;        else p=p-&gt;rkid;    &#125;//查找应该插入的位置    if (p!=NULL)&#123;//已经存在该节点         p-&gt;cnt=p-&gt;cnt + 1;        free(now);        return;    &#125;    //不存在该节点，需要插入，注意pp是父亲     if (val&lt;pp-&gt;val) pp-&gt;lkid=now;    else pp-&gt;rkid=now;    now-&gt;fa=pp;    if (pp-&gt;color==RED) insert_adjust(ptree,now);    //违反性质，连续两个红色了，失衡 &#125;int main()&#123;    return 0;&#125;\r\n好吧先鸽着，以后再碰到什么想不开的事情再来填坑.\r\nSplay平衡树\r\n基本操作\r\n顾名思义，splay的中文是伸展，而伸展操作中，最重要的是旋转，正巧和上文红黑树中的左旋和右旋是一样的意思，并且旋转之后中序遍历不变，BST性质保持。那么接下来就是伸展。伸展就是通过旋转，将一个节点转移到另外一个节点的下方。比如Splay(x,k)就是把x转到k的下方，特殊的Splay(x,0)是把x转到根。不难发现k应该是x的祖先。\r\n下面说明伸展的具体步骤，这边就已Splay(x,k)为例说明 ：\r\n\r\nx的父亲是k，那么已经满足条件\r\nx的爷爷是k，只需要一次旋转。x是左儿子就右旋，x是右儿子就左旋。\r\nx的父亲和爷爷都不是k但是x和他的父亲和爷爷共线，只要先旋转父亲，再旋转自己然后一直向上递归直到结束即可\r\n不共线。只要连续转两次即可，如果x是左儿子就右旋，x是右儿子就左旋\r\n\r\nSplay\r\n一个好习惯是进行对一个节点操作之后就Splay该节点到根节点。\r\n哨兵\r\n为了防止边界情况，使用INF和-INF作为树的哨兵防止越界。\r\n查找\r\n只要按照BST的性质向下查找即可。\r\n然后将当前节点换至根节点。\r\n前驱&amp;后继\r\n和红黑树中描述一样，前驱是左子树中最大的，后继是右子树中最小的。\r\n插入\r\n查找到需要插入的位置插入，然后将新元素旋转到根。\r\n删除\r\n不难发现在splay中，叶子结点的删除会简单很多，那么也就是要将节点变成叶子节点然后删除。\r\n这里有一个很好的思路，使用一个节点的前驱和后继，前驱做根，后继做右节点，那么当前节点右子树的左子树有且只有一个节点也就是要被删除的节点。（哨兵除外）\r\n排名\r\n显然是一个节点作为根之后左子树的大小.（别忘了还有一个哨兵）\r\n查询排名为rank的数值\r\n从根节点枚举，根据左子树大小和根节点数字个数来判断往哪里递归或是结束递归。\r\n可以使用数组模拟链表，实现难度相比红黑树小很多。（问题的种类数少很多。）\r\nP3369\r\n【模板】普通平衡树 - 洛谷\r\n然后经过博主一天的奋斗，终于是第一遍完全靠自己理解打出了这个沟槽的板子，非常开心\r\n#include&lt;cstdio&gt;#include&lt;ctype.h&gt;using namespace std;const int N=100005,INF=1&lt;&lt;30;int root=0,node_cnt;struct SPLAY&#123;    int son[2],fa,cnt,sum,val;    void Init(int p,int w)&#123;        fa=p;val=w;        sum=1;cnt=1;    &#125;&#125;tr[N];inline int read()&#123;    int x=0;char ch=getchar();bool flag=1;    while (!isdigit(ch))&#123;        if (ch==&#x27;-&#x27;) flag=0;        ch=getchar();    &#125;    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    if (flag) return x;    return -x;&#125;inline void update(int x)&#123;    tr[x].sum=tr[ tr[x].son[0] ].sum+tr[ tr[x].son[1] ].sum+tr[x].cnt;&#125;inline void rotate(int x)&#123;    int father=tr[x].fa,grand=tr[father].fa;    bool now=(tr[father].son[1]==x);    //father和grandfather关系变化     tr[grand].son[tr[grand].son[1]==father]=x;    tr[x].fa=grand;    //x的子树移给father     tr[father].son[now]=tr[x].son[now^1];    tr[tr[x].son[now^1]].fa=father;    //x旋转到father的位置    tr[father].fa=x;    tr[x].son[now^1]=father;    update(father);update(x); &#125;inline void Splay(int x,int k)&#123;    while (tr[x].fa!=k)&#123;        int father=tr[x].fa,grand=tr[father].fa;        if (grand!=k)            if ((tr[father].son[0]==x)^(tr[grand].son[0]==father)) rotate(x);            else rotate(father);//第一个条件直线，第二个不呈直线         rotate(x);    &#125;    if (k==0) root=x;&#125;inline void Insert(int w)&#123;    int rt=root,ptr=0;    while (rt &amp;&amp; tr[rt].val!=w)&#123;        ptr=rt;        rt=tr[rt].son[w&gt;tr[rt].val];    &#125;    if (rt) tr[rt].cnt++;    else&#123;        rt=++node_cnt;        tr[ptr].son[w&gt;tr[ptr].val]=rt;        tr[rt].Init(ptr,w);    &#125;    Splay(rt,0);&#125;inline void find(int w)&#123;    int rt=root;    while (tr[rt].son[w&gt;tr[rt].val] &amp;&amp; tr[rt].val!=w) rt=tr[rt].son[w&gt;tr[rt].val];    Splay(rt,0);&#125;inline int PRE(int w)&#123;    find(w);    int rt=root;    if (w&gt;tr[rt].val) return rt;    rt=tr[rt].son[0];    while (tr[rt].son[1]) rt=tr[rt].son[1];    Splay(rt,0);    return rt;&#125;inline int NXT(int w)&#123;    find(w);    int rt=root;    if (w&lt;tr[rt].val) return rt;    rt=tr[rt].son[1];    while (tr[rt].son[0]) rt=tr[rt].son[0];    Splay(rt,0);    return rt;&#125;inline void Delete(int w)&#123;    int pre=PRE(w),nxt=NXT(w);    Splay(pre,0);Splay(nxt,pre);    int now=tr[nxt].son[0];    if (tr[now].cnt&gt;1)&#123;        tr[now].cnt--;        Splay(now,0);    &#125;else&#123;        tr[nxt].son[0]=0;        Splay(nxt,0);    &#125;&#125;inline int query_rank(int w)&#123;    Insert(w);    int res=tr[tr[root].son[0]].sum;    Delete(w);    return res;&#125;inline int query_val(int loc)&#123;    int rt=root;    while (1)&#123;        if (loc&lt;=tr[tr[rt].son[0]].sum) rt=tr[rt].son[0];        else if (loc&lt;=tr[tr[rt].son[0]].sum+tr[rt].cnt) break;        else&#123;            loc-=tr[tr[rt].son[0]].sum+tr[rt].cnt;            rt=tr[rt].son[1];        &#125;    &#125;    Splay(rt,0);    return tr[rt].val;&#125;int main()&#123;    int T=read();    Insert(INF);Insert(-INF);    while (T--)&#123;        char opt=read();        if (opt==1)&#123;            int x=read();            Insert(x);        &#125;else if (opt==2)&#123;            int x=read();            Delete(x);        &#125;else if (opt==3)&#123;            int x=read();            printf(&quot;%d\\n&quot;,query_rank(x));        &#125;else if (opt==4)&#123;            int x=read();            printf(&quot;%d\\n&quot;,query_val(x+1));        &#125;else if (opt==5)&#123;            int x=read();            printf(&quot;%d\\n&quot;,tr[PRE(x)].val);        &#125;else if (opt==6)&#123;            int x=read();            printf(&quot;%d\\n&quot;,tr[NXT(x)].val);        &#125;    &#125;    return 0;&#125;\r\n红黑树真的有点力竭了，目前是删除还存在一些问题，只能过两个点\r\nTreap\r\n=tree+heap这里埋一个坑，博主今天不想做平衡树了\r\n暂时完结撒花！后续treap应该会单开一文，红黑树再更新也会单开一文。\r\nAnyway，总算是学会了一直觉得很吊的平衡树！\r\n再见咯，十月五号\r\n\r\n\r\n","categories":["学习"],"tags":["C++","数据结构","平衡树，模板"]},{"title":"P4735 最大异或和","url":"/2025/10/05/P4735-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/","content":"题目大意\r\n传送门(题面简洁明了)\r\n\r\n两种做法，可持久化trie树，离线+trie树前一种还没学，所以用了lowlow的第二种\r\n总体来说就是先离线排序出加入的顺序，根据询问建树，一边建树一边回答询问最终将答案按照原定顺序输出，在trie树上维护经过此点的最大区间下标即可，这样就可以判断是否在给出区间的左边界之后了。trie树建树就是常规的01trie前缀和建树转化区间求前缀的思路。\r\n非常重要！以后在出现函数的时候不要想着玩类似++cnt或者cnt++的把戏，非常容易出错！多打一行代码不会死。\r\n下面上代码\r\n#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#include&lt;algorithm&gt;using namespace std;const int LEN=6000005,N=600005;int n,m,tot=1,cnt,a[N],ans[N],tr[LEN][2],sec[LEN][2];struct XOR&#123;    int l,r,x,now,id;    XOR()&#123;&#125;    XOR(int L,int R,int X,int NOW,int ID): l(L),r(R),x(X),now(NOW),id(ID)&#123;&#125;&#125;b[N];inline int read()&#123;    int x=0;char ch=getchar();    while (!isdigit(ch)) ch=getchar();    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    return x;&#125;inline bool cmp(XOR a,XOR b)&#123;return a.r&lt;b.r;&#125;inline void insert(int x,int loc)&#123;    for (int i=25,rt=1;~i;i--)&#123;        bool now=(x&gt;&gt;i)&amp;1;        if (!tr[rt][now]) tr[rt][now]=++tot;        sec[rt][now]=loc;        rt=tr[rt][now];    &#125;&#125;inline int query(int x,int loc)&#123;    int res=0;    for (int i=25,rt=1;~i;i--)&#123;        bool now=(x&gt;&gt;i)&amp;1;        if (tr[rt][now^1] &amp;&amp; sec[rt][now^1]&gt;=loc)&#123;            res|=1&lt;&lt;i;            rt=tr[rt][now^1];        &#125;else rt=tr[rt][now];    &#125;    return res;&#125;int main()&#123;    n=read();m=read();    for (int i=1;i&lt;=n;i++) a[i]=read();    for (int i=1;i&lt;=m;i++)&#123;        char ch=getchar();        while (ch!=&#x27;A&#x27; &amp;&amp; ch!=&#x27;Q&#x27;) ch=getchar();        if (ch==&#x27;A&#x27;) a[++n]=read();        else&#123;            int l=read(),r=read(),x=read();            cnt++;            b[cnt]=XOR(l,r,x,n,cnt);        &#125;    &#125;    for (int i=n;i;i--) a[i]^=a[i+1];    sort(b+1,b+cnt+1,cmp);    for (int i=1,ptr=1;i&lt;=cnt;i++)&#123;        while (ptr&lt;=b[i].r)&#123;            insert(a[ptr],ptr);            ptr++;        &#125;        ans[b[i].id]=query(a[b[i].now+1]^b[i].x,b[i].l);    &#125;    for (int i=1;i&lt;=cnt;i++) printf(&quot;%d\\n&quot;,ans[i]);    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","trie树"]},{"title":"P3435 [POI 2006] OKR-Periods of Words","url":"/2025/10/03/P3435-POI-2006-OKR-Periods-of-Words/","content":"题目大意\r\n题目定义了一个“最大周期”，也就是长度最大的一个符合条件的字符串前缀，原字符串是该前缀两倍的前缀。要求求出所有前缀的最大周期长度之和。（不存在最大周期即长度为0）\r\n\r\n再一次更加明白了KMP的内涵吧。对于进行到第i位而言，只要存在前缀和后缀相同，也就是kmp[i]存在，那么显然一定存在最大周期，要想周期最大，那么显然是该字符串最短后缀的前半部分，因为最短后缀的前半部分重复两遍必然构成符合条件的字符串，且因为后缀最短，此时求出的一定是最大周期，那么只要先求出kmp，再根据kmp的性质，递归求出最短后缀（其实也就是前缀）的长度就好了，最后用一个小trick，学习了一下并查集的路径压缩，就可以进一步压缩时间复杂度，大概是O(nlog*n)还是蛮优秀的复杂度\r\n#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N=1000005;int len,kmp[N];char s[N];inline int find(int j)&#123;\tif (kmp[j]) return kmp[j]=find(kmp[j]);\treturn j;&#125;int main()&#123;\tscanf(&quot;%d%s&quot;,&amp;len,s+1);\tfor (int i=2,j=0;i&lt;=len;i++)&#123;\t\twhile (j &amp;&amp; s[j+1]!=s[i]) j=kmp[j];\t\tif (s[j+1]==s[i]) j++;\t\tkmp[i]=j;\t&#125;\tlong long ans=0;\tfor (int i=2,j=2;i&lt;=len;i++,j=i)&#123;\t\tj=find(j);\t\tans+=i-j;\t&#125;\tprintf(&quot;%lld\\n&quot;,ans);\treturn 0;&#125; \r\n代码还是蛮简短明了的，再见咯，十月三号。\r\n\r\n\r\n","categories":["学习"],"tags":["C++","KMP"]},{"title":"20251003小记","url":"/2025/10/03/20251003%E5%B0%8F%E8%AE%B0/","content":"首先是以后学习一定要注意细节！！！昨天一个代码只是因为一开始输入的时候大意了多打了一个n–，没有很好的理清关系，以为是主体部分出错导致调试了近两个半小时，非常不值当且让人心态爆炸，一定要注意以后。\r\n然后是很开心！又有一个室友昨天回来了哈哈哈哈寝室里呆着就没有那么孤独。以及昨天好久不见的初中哥们Wu同学来成都玩！srds吐槽一下绿皮计划五点半到达，但是接到人的时候已经八点了，等了非常久且肚子饿饿TAT.但是！晚上吃的火锅真的很满足哈哈哈哈哈但是大出血了当时太晚了很多烟火小店关门了只能到大店吃性价比真的一般打车回学校之后室友还没睡！并且后来和Wang同学激情电话（当然了没有在寝室里不要喷博主emm）非常快乐地就熬到了今天早上的凌晨，和室友吃了麦麦早餐之后就把他送走了（哥们旅游去了）。今天倒是平平淡淡没发生啥事，打扫了一下寝室的卫生履行一下这个”寝室长”的职责哈哈哈哈哈哈，重新开始我省钱的泡面计划哈哈哈哈哈哈，今日跑步休息一天因为膝盖的问题，明天继续。\r\n\r\n\r\n\r\n","categories":["日记"],"tags":["碎碎念"]},{"title":"P2375 [NOI2014] 动物园","url":"/2025/10/03/P2375-NOI2014-%E5%8A%A8%E7%89%A9%E5%9B%AD/","content":"题目大意\r\n这篇题目的描述实在是废话太多了\r\n对于N个字符串，求出从头开始到i(1 ≤ i ≤ n)结束的时候每一次前缀等于后缀的数量\r\n并且前后缀不能重合\r\n比如字符串aaaa，i=4时，就有a和aa两个前后缀符合这个特点\r\n\r\n总体思路\r\nKMP+DP\r\n先抛开前缀后缀不重叠的限制\r\nKMP可以求出到第i位时最长的一致前缀和后缀，那么考虑每一个一致的前缀和后缀\r\n不难发现这时某一个字符串拥有的数量一定是他最长一致前后缀拥有的数量+1也就是多出了最长一致前后缀本身的那一组。\r\n剩下的就很简单了，\r\n由于一致前后缀的一致前后缀一定是一致前后缀\r\n(a是aa的一致前后缀，aa是aaaa的一致前后缀，a显然是aaaa的一致前后缀)\r\n只需要在累乘的时候不断地将指针跳到KMP算法求出的前一个位置，直到小于当前长度的一半，此时DP数组的值就是当前的一致前后缀数量。\r\n细节看代码，模数较大的时候一定要开long long\r\n#include&lt;cstdio&gt;#include&lt;cstring&gt;#define int long longusing namespace std;const int mod=1000000007,N=1000005;int kmp[N],sum[N];char s[N];signed main()&#123;\tint T;scanf(&quot;%lld&quot;,&amp;T);\twhile (T--)&#123;\t\tmemset(kmp,0,sizeof(kmp));\t\tmemset(sum,0,sizeof(sum));\t\tsum[1]=1;\t\tscanf(&quot;%s&quot;,s+1);\t\tint len=strlen(s+1),j=0;\t\tfor (int i=2;i&lt;=len;i++)&#123;\t\t\twhile (j &amp;&amp; s[j+1]!=s[i]) j=kmp[j];\t\t\tif (s[j+1]==s[i]) j++;\t\t\tkmp[i]=j;sum[i]=sum[j]+1;\t\t&#125;\t\tj=0;int ans=1;\t\tfor (int i=2;i&lt;=len;i++)&#123;\t\t\twhile (j &amp;&amp; s[j+1]!=s[i]) j=kmp[j];\t\t\tif (s[j+1]==s[i]) j++;\t\t\twhile (i&lt;(j&lt;&lt;1)) j=kmp[j];\t\t\tans=(ans*(sum[j]+1))%mod;\t\t&#125;\t\tprintf(&quot;%lld\\n&quot;,ans);\t&#125;\treturn 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","KMP","DP"]},{"title":"P2922 [USACO08DEC] Secret Message G","url":"/2025/10/03/P2922-USACO08DEC-Secret-Message-G/","content":"题目大意：\r\n给出两组01串组，求问后面一组是前面的前缀或后缀的数量\r\n01trie树板子题，注意两串相等的情况即可\r\n\r\n#include&lt;cstdio&gt;using namespace std;const int N=50005;int n,m,tot,trie[500005][2],siz[500005],End[500005];bool M[N];inline void insert(int T,int rt=0)&#123;    for (int i=0;i&lt;T;i++)&#123;        siz[rt]++;        bool now=M[i];        if (!trie[rt][now]) trie[rt][now]=++tot;        rt=trie[rt][now];    &#125;    siz[rt]++;End[rt]++;&#125;inline int query(int T,int rt=0)&#123;    int res=0;    for (int i=0;i&lt;T;i++)&#123;        res+=End[rt];        bool now=M[i];        if (trie[rt][now]) rt=trie[rt][now];        else return res;    &#125;    return res+siz[rt];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for (int i=1;i&lt;=m;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        for (int j=0;j&lt;x;j++)&#123;            char ch=getchar();            while (ch!=&#x27;0&#x27; &amp;&amp; ch!=&#x27;1&#x27;) ch=getchar();            M[j]=ch-&#x27;0&#x27;;        &#125;        insert(x);    &#125;    for (int i=1;i&lt;=n;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        for (int j=0;j&lt;x;j++)&#123;            char ch=getchar();            while (ch!=&#x27;0&#x27; &amp;&amp; ch!=&#x27;1&#x27;) ch=getchar();            M[j]=ch-&#x27;0&#x27;;        &#125;        printf(&quot;%d\\n&quot;,query(x));    &#125;    return 0;&#125;\r\n完结撒花★,°:.☆(￣▽￣)/$:.°★ 。\r\n\r\n\r\n","categories":["学习"],"tags":["C++","trie树"]},{"title":"luoguP5283 [十二省联考 2019] 异或粽子","url":"/2025/10/02/luoguP5283-%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%83-2019-%E5%BC%82%E6%88%96%E7%B2%BD%E5%AD%90/","content":"题目大意\r\n给出n个数的数列，要求找到k个组合[l,r]使这k个组合各个区间的异或后的和最大。\r\n\r\n整体思路\r\n首先鸽一下持久化trie树的做法，咳咳这个以后再说.本文介绍的是另一种实现简单一点的做法\r\n首先审题发现0 ≤ ai ≤ 4294967295，那么显然int的范围不够，千万不能因为细节丢分。\r\n那么首先根据题目中区间的设定和异或的性质很容易想到前缀”和”的想法。那么区间的异或值就可以O(1)求解了也就是sl − 1 ⊕ sr\r\n观察后可以发现一共有n2对组合，显然不能直接枚举，根据异或联想到01trie树可以log时间内解决区间第k大异或值的问题，那么问题就变成了:\r\n对于s0 − sn,构建一颗01trie树，并且先求出对于每一个si(0 ≤ i ≤ n)来说最优的sj，加入大根堆，这样出来的一定是第一大值，后续对于每次求出的最大值将对于该si来说的下一大值加入大根堆，这个贪心的思路可以保证每次取出的一定是当前最大值，并且由于01trie树的性质，每次取出的一定是不同的数列，除非i, j颠倒。\r\n那么对于i, j颠倒很好处理，显然如果i, j在答案队列中，j, i一定在答案中，那么只需要将原题中的k翻倍，这样选出来一定是完整的两对i, j，最后将ans折半输出即可，对于i = j的情况显然自己与自己的异或和是0，显然对答案不会有贡献。\r\n一个小坑\r\n博主在写trie树的时候总是容易忘记trie树的根是一个虚根，是无意义的，所以如果root = 1的话，记得trie树编号要从2开始！调了蛮久的。以及因为懒，直接define int long long\r\n了Emmmmm好像常数会大所以打了快读\r\n代码\r\n#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#define int long longusing namespace std;const int N=500005,TR=20000005;int n,k,tot=1,siz[TR],tr[TR][2],a[N];struct XOR&#123;    int id,rk,w;    XOR()&#123;&#125;    XOR(int x,int y,int z): id(x),rk(y),w(z)&#123;&#125;&#125;;inline bool operator &lt; (const XOR&amp; a,const XOR&amp; b)&#123;return a.w&lt;b.w;&#125;priority_queue&lt;XOR&gt; s;inline int read()&#123;    int x=0;char ch=getchar();    while (!isdigit(ch)) ch=getchar();    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    return x;&#125;inline void insert(int x,int rt=1)&#123;    siz[rt]++;    for (int i=31;~i;i--)&#123;        int now=(x&gt;&gt;i)&amp;1;        if (!tr[rt][now]) tr[rt][now]=++tot;        rt=tr[rt][now];        siz[rt]++;    &#125;&#125;inline int query(int x,int rk,int rt=1)&#123;    int res=0;    for (int i=31;~i;i--)&#123;        int now=(x&gt;&gt;i)&amp;1;        if (tr[rt][now^1])            if (rk&lt;=siz[tr[rt][now^1]])&#123;                res|=1ll&lt;&lt;i;                rt=tr[rt][now^1];            &#125;else&#123;                rk-=siz[tr[rt][now^1]];                rt=tr[rt][now];            &#125;        else rt=tr[rt][now];    &#125;    return res;&#125;signed main()&#123;    n=read();k=read()&lt;&lt;1;    insert(0);    for (int i=1;i&lt;=n;i++)&#123;        int x=read();        a[i]=a[i-1]^x;        insert(a[i]);    &#125;    for (int i=0;i&lt;=n;i++) s.push(XOR(i,1,query(a[i],1)));    int ans=0;    while (k--)&#123;        XOR now=s.top();s.pop();ans+=now.w;        if (now.rk&lt;n) s.push(XOR(now.id,now.rk+1,query(a[now.id],now.rk+1)));    &#125;    printf(&quot;%lld\\n&quot;,ans&gt;&gt;1);    return 0;&#125;\r\n完结撒花\r\n\r\n\r\n","categories":["学习"],"tags":["C++","STL","trie树","luogu"]},{"title":"struct重载运算符小记","url":"/2025/10/02/struct%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B0%8F%E8%AE%B0/","content":"结构体中的重构\r\n首先定义一个结构体\r\nstruct Example&#123;    int x,y,z;&#125;;\r\n那么第一是定义默认赋值顺序:\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;&#125;;\r\n那么就可以保证不管如何赋值的顺序一定是x,y,z当然现在C++的默认顺序是变量名给出的顺序，一般情况下不会出错，相当于上了一层保险。\r\n但是想要在结构体内直接使用运算符重载这是必须的。\r\n接下来记录比较符号(&lt;,&gt;,=等)的运算符重载\r\n\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;&#125;;\r\n那么上面的小于号例子就是将x的大小作为正常的&lt;比较对象。如果要改变规则很简单比如想让大根堆变为小根堆只需要将符号的方向改变也就是将即可。\r\n那么接下来是对运算符的重载\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;    inline Example operator + (Example&amp; r)&#123;        x=x+r.x;y=y+r.y;z=z+r.z;        return Example(x,y,z);    &#125;&#125;;\r\n与指针的方法相比，这种方式显然更好理解，所以将这种方式记录下来。其他的运算符同理\r\n最后是赋值运算符=的运算符重载\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;    inline Example operator + (Example&amp; r)&#123;        x=x+r.x;y=y+r.y;z=z+r.z;        return Example(x,y,z);    &#125;    inline Example operator = (Example&amp; r)&#123;        x=r.x;y=r.y;z=r.z;        return *this;    &#125;&#125;;\r\n由于赋值运算符的特殊性，这样子的方法更加稳健。\r\n结构体外的重构\r\n这里沿用上面struct的设定\r\n那么重载就变成了这样:\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;&#125;;inline Example operator + (const Example&amp; a,const Example&amp; b)&#123;    return Example(a.x+b.x,a.y+b.y,a.z+b.z);&#125;inline bool operator &lt;(const Example&amp; a,const Example&amp; b)&#123;    if (a.x==b.x)         if (a.y==b.y) return a.z&lt;b.z;        else return a.y&lt;b.y;    return a.x&lt;b.x;&#125;\r\n那么结构体外就可以将=和+，-视为一样的进行操作了。\r\n个人更加喜欢结构体外的重构，含义更加明了方便理解可以减少出错。\r\n那么基础性的运算符重载部分就这样结束啦！\r\n\r\n\r\n","categories":["学习"],"tags":["C++","结构体","零碎知识点"]},{"title":"20251001小记","url":"/2025/10/01/20251001%E5%B0%8F%E8%AE%B0/","content":"祝大家双节快乐！\r\n和九月告别，和十月初见。由于上次摔车腿伤逐渐恢复，恢复了跑步和上肢的寝室小运动。非常感动的是中午室友回来看我了！！！！让孤寂一人在寝的我得到了极大的慰藉哈哈哈哈哈哈。出乎意料的没有放假的激动，好像就是很平常的一个早上我很平常地醒了然后一如既往地去楼下学子餐厅的麦当劳吃早饭，平平淡淡才是真嘛。\r\n\r\n总算是把烦人的大物搞定啦，这样子就没有学业上的东西干扰了，明天可以开始进行ACM的刷题了。再就是明天初中哥们就来成都啦，一定要请他们去吃地道老蹄花儿，一吃一个不吱声。虽然很晚了但好歹是没有迟到更新哈哈哈哈哈，祝我和大家都能过一个快乐的国庆！\r\n\r\n\r\n","categories":["日记"],"tags":["碎碎念"]},{"title":"20250930小记","url":"/2025/09/30/20250930%E5%B0%8F%E8%AE%B0/","content":"放国庆啦！\r\n\r\n最后一节课果然还是一点没听进去，八天小长假但是呆在学校里不回家，貌似有点惨但是也还好。昨天帮舍友哥们和嫂子抢到了紫琪姐的演唱会门票，为了未来行程提早完成了大学物理实验第二次实验，新生球队也总算是井井有条变得有生气了。膝盖距离上次摔车已经过了快一周了，好得差不多但是骑车走路的时候还是会有影响，以后还是要好好注意。上一周过了非常萎靡且摆烂的生活哈哈哈哈哈哈哈哈，明天开始好好奋斗咯！而且运动要恢复起来了，制定一下！国庆每天跑五公里！加上小项的训练，英语六级需要提上日程，ACM刷题也要恢复咯。大学物理的第二次作业DDL也近了。(ง\r\n•_•)ง\r\n\r\n\r\n","categories":["日记"],"tags":["碎碎念"]},{"title":"First Blog","url":"/2025/09/30/First-Blog/","content":"历经两天终于是搭建完成了我的BLOG！上次想搭博客还是初中的时候2019年一转眼六年过去了，初中生变成了初生大学生，实在是有些快，好像经历了很多又好像什么都没干。之后的人生一定要目标明确地努力咯，好歹是知道了想干什么。第一篇文章也不知道还要说啥，看到这篇文章的兄弟们共勉吧！然后放下两张图说不定有好心人呢\r\n\r\n\r\n\r\n微信\r\n\r\n（逃\r\n\r\n\r\n","categories":["生活"],"tags":["碎碎念"]}]