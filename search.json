[{"title":"P1816 忠诚","url":"/2025/10/07/P1816-%E5%BF%A0%E8%AF%9A/","content":"题目概述\r\nP1816 忠诚 -\r\n洛谷\r\n给出一串数列，求区间最小值。\r\n题目思路\r\n由于刚刚学会了ST表，使用ST表进行解决。\r\n\r\n刚开始学会ST表的时候意识到一定要搞清楚他的定义\r\n比如这里就是nxt[i][j]表示第i位开始2j的长度内的最小值，比如j = 0时区间长度为20 = 1也就是此时nxt[i][j]代表本身\r\n那么类似动态规划转移方程就是nxt[i][j] = min(nxt[i][j − 1], nxt[i + 2j − 1][j − 1]\r\n那么答案要求的区间最小值也自然是先求出区间步长k = log2(r − l + 1)\r\n由于是向下取整，那么显然答案分为两个区间，也就是\r\nans = min(nxt[l][k], nxt[r − 2k + 1][k])\r\n下面就是代码了\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#include&lt;algorithm&gt;using namespace std;const int N=100005;int n,m,val[N][20],nxt[N][20];inline int read()&#123;    int x=0;char ch=getchar();    while (!isdigit(ch)) ch=getchar();    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    return x;&#125;int main()&#123;    n=read();m=read();    for (int i=1;i&lt;=n;i++)&#123;        int x=read();        nxt[i][0]=x;    &#125;    for (int i=1;i&lt;20;i++)        for (int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++)            nxt[j][i]=min(nxt[j][i-1],nxt[j+(1&lt;&lt;i-1)][i-1]);    while (m--)&#123;        int x=read(),y=read(),k=log2(y-x+1);        printf(&quot;%d &quot;,min(nxt[x][k],nxt[y-(1&lt;&lt;k)+1][k]));    &#125;    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","数据结构","ST表"]},{"title":"P4155 [SCOI2015] 国旗计划","url":"/2025/10/07/P4155-SCOI2015-%E5%9B%BD%E6%97%97%E8%AE%A1%E5%88%92/","content":"题目传送门\r\nP4155 [SCOI2015]\r\n国旗计划 - 洛谷\r\n题目大意\r\n给出n条线段，环上一共m个点，求在第i条线段必须使用时最少要使用及条线段，数据保证线段不会被另外一条线段包涵。\r\n\r\n解题思路\r\n博主才知道原来这种使用倍增思想的可以解决重复问题的这种数组类的数据结构是ST表Emmm\r\n那么就是先破环成链，然后对于左端点从左到右排序，根据每段线段求出最远的跳跃目标（这里使用贪心思想，因为不会被包涵，所以左端点越远右端点一定越远，使用越远的线段那么使用的条数一定越少）。那么求出了第一次的跳跃目标之后使用ST表将重复查询的时间复杂度由线性转化为O(log2n)那么总体的时间复杂度就是排序和后续查找的O(nlogn)了\r\n#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=200005;int n,m,ans[N],nxt[N&lt;&lt;1][20];struct SOL&#123;int l,r,id;&#125;a[N&lt;&lt;1];inline bool cmp(SOL x,SOL y)&#123;return x.l&lt;y.l;&#125;int main()&#123;\tscanf(&quot;%d%d&quot;,&amp;n,&amp;m);\tfor (int i=1;i&lt;=n;i++)&#123;\t\tint x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\t\ta[i].l=x;\t\tif (x&lt;y) a[i].r=y;else a[i].r=y+m;\t\ta[i].id=i;\t&#125;\tsort(a+1,a+n+1,cmp);\tfor (int i=1;i&lt;=n;i++)&#123;\t\ta[i+n].l=a[i].l+m;\t\ta[i+n].r=a[i].r+m;\t&#125;\tn&lt;&lt;=1;\tfor (int i=1,j=1;i&lt;=n;i++)&#123;\t\twhile (j&lt;=n &amp;&amp; a[j].l&lt;=a[i].r) j++;\t\tnxt[i][0]=j-1;\t&#125;\tfor (int i=1;i&lt;20;i++)\t\tfor (int j=1;j&lt;=n;j++) nxt[j][i]=nxt[nxt[j][i-1]][i-1];\tn&gt;&gt;=1;\tfor (int i=1;i&lt;=n;i++)&#123;\t\tint now=i;\t\tfor (int j=19;~j;j--)&#123;\t\t\tif (nxt[now][j] &amp;&amp; a[nxt[now][j]].r&lt;a[i].l+m)&#123;\t\t\t\tnow=nxt[now][j];\t\t\t\tans[a[i].id]+=(1&lt;&lt;j);\t\t\t&#125;\t\t&#125;\t&#125;\tfor (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]+2);\treturn 0;&#125;\r\n\r\n\r\n","tags":["C++","数据结构","ST表","贪心"]},{"title":"P3509 [POI 2010] ZAB-Frog","url":"/2025/10/06/P3509-POI-2010-ZAB-Frog/","content":"题目链接\r\nP3509 [POI 2010]\r\nZAB-Frog - 洛谷\r\n题目大意\r\n给出n个位置，对于每个位置的下一次会跳跃到距离该位置最近的第k个位置，有相同距离的选左边，询问对于每个位置跳跃m次之后会处在哪个位置。\r\n\r\n解题思路\r\n观察范围:1 ≤ k &lt; n ≤ 106, 1 ≤ m ≤ 1018\r\n首先就是想到了对于m次跳跃可以先处理出一次的然后根据倍增处理出跳跃m位之后的情况\r\n那么对于处理出一次，可以使用单调队列来维护。\r\n并且相比于窗口滑动这类题目更加简单，只需要维护两端的指针就好了。\r\n那么对于每一个节点来说，只有两端的位置可能是下一个，显然远端（或是相同距离的左端）会成为下一个跳跃到的节点。\r\n于是代码就写好了\r\n#include&lt;cstdio&gt;using namespace std;int n,k,nxt[1000001][60];long long m,p[1000005];inline void Init()&#123;    for (int i=1;i&lt;=n;i++)        for (int j=1;j&lt;=59;j++) nxt[i][j]=nxt[nxt[i][j-1]][j-1];&#125;inline int find(int now,long long x)&#123;    for (int i=59;~i;i--)        if (x&gt;=(1ll&lt;&lt;i))&#123;            now=nxt[now][i];            x-=(1&lt;&lt;i);            if (x==0) return now;        &#125;    return now;&#125;int main()&#123;    scanf(&quot;%d%d%lld&quot;,&amp;n,&amp;k,&amp;m);    for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;p[i]);    int l=1,r=k+1;    for (int i=1;i&lt;=n;i++)&#123;        while (r+1&lt;=n &amp;&amp; p[r+1]-p[i]&lt;p[i]-p[l])&#123;            l++;            r++;        &#125;        if (p[i]-p[l]&gt;=p[r]-p[i]) nxt[i][0]=l;        else nxt[i][0]=r;    &#125;    Init();    for (int i=1;i&lt;=n;i++)        printf(&quot;%d &quot;,find(i,m));    printf(&quot;\\n&quot;);    return 0;&#125;\r\n信心满满一波提交！但是！喜提26分\r\n记录详情 - 洛谷 |\r\n计算机科学教育新生态\r\n为什么呢，观察到内存只有125MB并且非常严格，直接导致空间的溢出造成WA和MLE.\r\n于是博主百思不得起解查看了题解。\r\n然后震惊于题解思路，非常巧妙地借鉴了快速幂的思想，使用一样的时间复杂度和优秀的空间复杂度完成了任务。\r\n于是最终版本就是这样\r\n#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N=1000005;int n,k,nxt[N],ans[N],t[N];long long m,p[N];inline void Init(long long x)&#123;    for (int i=1;i&lt;=n;i++) ans[i]=i;    while (x)&#123;        if (x&amp;1) for (int i=1;i&lt;=n;i++) ans[i]=nxt[ans[i]];        memcpy(t,nxt,sizeof(nxt));        for (int i=1;i&lt;=n;i++) nxt[i]=t[t[i]];        x&gt;&gt;=1;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d%lld&quot;,&amp;n,&amp;k,&amp;m);    for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;p[i]);    int l=1,r=k+1;    for (int i=1;i&lt;=n;i++)&#123;        while (r+1&lt;=n &amp;&amp; p[r+1]-p[i]&lt;p[i]-p[l])&#123;            l++;            r++;        &#125;        if (p[i]-p[l]&gt;=p[r]-p[i]) nxt[i]=l;        else nxt[i]=r;    &#125;    Init(m);    for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]);     printf(&quot;\\n&quot;);    return 0;&#125;\r\n再见咯,2025/10/06\r\n\r\n\r\n","categories":["学习"],"tags":["C++","贪心","倍增","单调队列"]},{"title":"P5094 [USACO04OPEN] MooFest G 加强版","url":"/2025/10/06/P5094-USACO04OPEN-MooFest-G-%E5%8A%A0%E5%BC%BA%E7%89%88/","content":"题目链接\r\nP5094 [USACO04OPEN]\r\nMooFest G 加强版 - 洛谷\r\n题面解释的挺清楚的\r\n\r\n首先数据范围显然不能使用O(n2)的暴力，看到了max很自然地想到了排序后根据数值大小插入坐标然后根据一个点左边右边分别求区间和乘上当前位置的权值，单点修改，区间查询，很自然地想到线段树，注意同时维护区间和以及区间个数即可\r\n#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int N=50005;int n,mx,ans;struct code&#123;int sum,cnt;&#125;tr[N&lt;&lt;1];struct COW&#123;int v,x;&#125;a[N];inline bool cmp(COW a,COW b)&#123;return a.v&lt;b.v;&#125;inline int lowbit(int x)&#123;return x&amp;(-x);&#125;inline void insert(int x,int w)&#123;    while (x&lt;=mx)&#123;        tr[x].cnt++;        tr[x].sum+=w;        x+=lowbit(x);    &#125;&#125;inline code query(int x)&#123;    code res;res.cnt=0;res.sum=0;    while (x&gt;0)&#123;        res.cnt+=tr[x].cnt;        res.sum+=tr[x].sum;        x-=lowbit(x);    &#125;    return res;&#125;signed main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for (int i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;a[i].v,&amp;a[i].x),mx=max(mx,a[i].x);    sort(a+1,a+n+1,cmp);    for (int i=1;i&lt;=n;i++)&#123;        int now=a[i].v;        code left=query(a[i].x),right=query(mx);        right.cnt-=left.cnt;right.sum-=left.sum;        ans+=now*(a[i].x*left.cnt-left.sum+right.sum-a[i].x*right.cnt);        insert(a[i].x,a[i].x);    &#125;    printf(&quot;%lld\\n&quot;,ans);    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","数据结构","贪心","树状数组"]},{"title":"树状数组","url":"/2025/10/06/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","content":"模板题目参考\r\nP3374\r\n【模板】树状数组 1 - 洛谷\r\nP3368\r\n【模板】树状数组 2 - 洛谷\r\n区别在于单点修改，区间查询和区间修改，单点查询\r\n\r\n树状数组入门\r\n定义介绍\r\n树状数组只是运用了树结构的思想，但是其实并不是真的是构造树形结构，有点trie树的感觉。\r\n树状数组支持区间和，异或和，乘积和RMQ，朴素的树状数组只支持单点修改。\r\n含义\r\n对于每一个tree[i]实际上他维护了一段区间的信息，而这个区间的长度一般是由lowbit(i)来决定，也就是i转换为二进制之后最后一位”1”出现的位置。根据这个定义我们可以写出\r\nlowbit(x) = x and (−x)注意此处and是与运算的意思。结合复数的二进制编码不难理解。那么各种操作也不难理解了\r\n单点（前缀和）查询\r\ninline int query(int x)&#123;    int res=0;    while (x)&#123;        res+=tr[x];        x-=lowbit(x);    &#125;    return res;&#125;//此处默认求前缀和 \r\n单点修改\r\ninline void modify(int x,int w)&#123;    while (x&lt;=n)&#123;        tr[x]+=w;        x+=lowbit(x);    &#125;&#125;//同样默认前缀和 \r\n那么模板二中的区间修改怎么实现？\r\n不难发现只要求单点修改了，联系到差分思想，只要将原来的所谓单点查询转化为差分数组前缀和，将原来的区间修改转化为对于差分之后数据的单点修改（也就是只改变区间头和区间尾）即可。\r\n然后放上两道模板题目的代码\r\n模板①\r\n#include&lt;cstdio&gt;using namespace std;const int N=500005;int n,m,tr[N&lt;&lt;1];inline int lowbit(int x)&#123;return x&amp;(-x);&#125;inline void plus(int x,int w)&#123;\twhile (x&lt;=n)&#123;\t\ttr[x]+=w;\t\tx+=lowbit(x);\t&#125;&#125;inline int query(int x)&#123;\tint res=0;\twhile (x&gt;0)&#123;\t\tres+=tr[x];\t\tx-=lowbit(x);\t&#125;\treturn res;&#125;int main()&#123;\tscanf(&quot;%d%d&quot;,&amp;n,&amp;m);\tfor (int i=1;i&lt;=n;i++)&#123;\t\tint x;scanf(&quot;%d&quot;,&amp;x);\t\tplus(i,x);\t&#125;\twhile (m--)&#123;\t\tint opt;scanf(&quot;%d&quot;,&amp;opt);\t\tif (opt==1)&#123;\t\t\tint x,k;scanf(&quot;%d%d&quot;,&amp;x,&amp;k);\t\t\tplus(x,k);\t\t&#125;else&#123;\t\t\tint x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\t\t\tprintf(&quot;%d\\n&quot;,query(y)-query(x-1));\t\t&#125;\t&#125;\treturn 0;&#125;\r\n模板②\r\n#include&lt;cstdio&gt;using namespace std;const int N=500005;int n,m,tr[N&lt;&lt;1];inline int lowbit(int x)&#123;return x&amp;(-x);&#125;inline void plus(int x,int w)&#123;\twhile (x&lt;=n)&#123;\t\ttr[x]+=w;\t\tx+=lowbit(x);\t&#125;&#125;inline int query(int x)&#123;\tint res=0;\twhile (x&gt;0)&#123;\t\tres+=tr[x];\t\tx-=lowbit(x);\t&#125;\treturn res;&#125;int main()&#123;\tscanf(&quot;%d%d&quot;,&amp;n,&amp;m);\tint now=0,lst=0;\tfor (int i=1;i&lt;=n;i++)&#123;\t\tscanf(&quot;%d&quot;,&amp;now);\t\tplus(i,now-lst);\t\tlst=now;\t&#125;\twhile (m--)&#123;\t\tint opt;scanf(&quot;%d&quot;,&amp;opt);\t\tif (opt==1)&#123;\t\t\tint x,y,k;scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;k);\t\t\tplus(x,k);\t\t\tplus(y+1,-k);\t\t&#125;else&#123;\t\t\tint x;scanf(&quot;%d&quot;,&amp;x);\t\t\tprintf(&quot;%d\\n&quot;,query(x));\t\t&#125;\t&#125;\treturn 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","数据结构","树状数组","模板"]},{"title":"P6824 「EZEC-4」可乐","url":"/2025/10/06/P6824-%E3%80%8CEZEC-4%E3%80%8D%E5%8F%AF%E4%B9%90/","content":"题目传送门\r\nP6824 「EZEC-4」可乐\r\n- 洛谷\r\n题目描述还是很清晰明了的\r\n思路过程\r\n最近看到异或就下意识思考trie树了，看到数据范围发现O(nlogn)可行。\r\n于是一个思路就出来了，暴力枚举每一个范围内的x，然后跑trie树看看对于这个x来说符合条件的“可乐”有几瓶，取max就好了\r\n\r\n一些百思不得其解的地方\r\n不知道为什么trie树insert和query循环的地方，我使用自己的变量的时候总是会出错，比如我for\r\n(int i=mx……)此时mx是8，但是跳出来答案就是0，但是我for(int\r\ni=8……)答案就是正确的，真的不知道为什么，非常玄学。所以注意\r\n以后不要乱使用全局变量，也不要乱玩前后缀++，–\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=1000005;int n,k,mx,ans,tot=1,a[N],tr[N*20][2],siz[N*20];inline void insert(int x)&#123;    for (int i=20,rt=1;~i;i--)&#123;        bool now=(x&gt;&gt;i)&amp;1;        if (!tr[rt][now]) tr[rt][now]=++tot;        rt=tr[rt][now];siz[rt]++;    &#125;&#125;inline int query(int x)&#123;    int res=0,rt=1;    for (int i=20;~i;i--)&#123;        bool now_k=(k&gt;&gt;i)&amp;1,now=(x&gt;&gt;i)&amp;1;        if (now_k==1)&#123;            res+=siz[tr[rt][now]];            rt=tr[rt][now^1];        &#125;else if (tr[rt][now]) rt=tr[rt][now];        else return res;    &#125;    return res+siz[rt];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    mx=(int)log2(k)+1;    for (int i=1;i&lt;=n;i++)&#123;        scanf(&quot;%d&quot;,&amp;a[i]);        insert(a[i]);        mx=max(mx,(int)log2(a[i])+1);    &#125;    int m=1&lt;&lt;mx;    for (int i=0;i&lt;=m;i++)&#123;        ans=max(ans,query(i));        if (ans==n)&#123;            printf(&quot;%d\\n&quot;,n);            return 0;        &#125;    &#125;    printf(&quot;%d\\n&quot;,ans);    return 0;&#125;\r\n完结★,°:.☆(￣▽￣)/$:.°★ 。\r\n\r\n\r\n","categories":["学习"],"tags":["C++","trie树"]},{"title":"二叉搜索树(BST)及红黑树、splay平衡树学习笔记","url":"/2025/10/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST-%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81splay%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"二叉搜索树Binary Search Tree\r\n定义\r\n是一棵满足中序遍历下节点的权值严格递增的特殊的二叉树.\r\n那么实际上也就是符合下面两个条件：\r\n\r\n左子树的节点小于当前节点\r\n右子树的节点大于当前节点\r\n不存在重复节点\r\n\r\n性质\r\n\r\n每个点的左右子树（如果存在的话）都是BST\r\n当前BST的最小节点一定是最左下的节点\r\n当前BST的最大节点一定是最右下的节点\r\n\r\n\r\n构建和插入节点\r\n从根节点开始，根节点不存在则构建根节点，否则，比较和当前节点的大小，小则往左走，大则往右走，知道发现节点X，发现要插入的值小于X且X没有左儿子，则插入为X的左儿子，要插入的值大于X且X没有右儿子，则插入为X的右儿子。\r\n删除节点\r\n查找需要删除的节点的过程省略（同上）\r\n那么找到以后，分几种情况处理\r\n叶子节点\r\n直接删除即可（将其父亲节点指向它的指针设置为空，权值清零）\r\n只有一边子树的节点\r\n发现也简单，只要将其父亲指向它的节点指向它唯一的儿子即可\r\n有两边子树的节点\r\n引入后继节点的概念，是整棵BST中权值最接近当前节点并且大于当前节点的节点。\r\n这里抛开叶子节点的情况，毕竟叶子节点不可能有两边子树\r\n那么一个结点的后继节点也就是这个节点右子树的最左下节点（不一定是叶子节点），也就是一直向左子树搜索知道不存在左子树为止的节点。\r\n那么删除这种节点的情况就好说了，只要将当前节点替换为他的后继节点即可，思考正确性，由于是本来节点的后继节点，在右子树，所以一定比左儿子大，因为是一路往左走且没有左儿子，所以一定是本来右子树里最小的，也就是删除之后右子树所有节点大于插入节点，符合原性质。\r\n修改节点\r\n先删除后添加即可\r\n以上就是二叉查找树(BST)的最基本知识，那么掌握了BST不难发现当数据构成一条链时，时间复杂度会从平均的log转向线性，也就是整棵树变成了链表。所以这时候就可以进一步加强使用自平衡二叉搜索树，也就是平衡树\r\n平衡树\r\n常用的平衡树（也是我要向学完的）是红黑树，splay，treap-旋转/非旋转。其中红黑树效率很高，splay是比赛中最常用的，因为码量不算非常大的情况下支持可持久化，合并，treap码量相对较小\r\n，但是和splay一样速度较慢。\r\n红黑树\r\n值得一提的是STL中的map和set就是使用红黑树实现的\r\n性质\r\n\r\n节点有两种颜色（原作者喜欢红色和黑色）\r\n根节点是黑色的\r\n所有叶子节点都是黑色的\r\n每个红色的节点一定有两个黑色的子节点\r\n从每个叶子到根的所有路径上都不能有两个连续的红色节点\r\n从任何节点到每个叶子的所有简单路径都包含相同数目的黑色节点（这里简称黑高）\r\n\r\n在以上条件的束缚下，路径最长的情况下红色节点数量=黑色节点数量，路径长度为两倍黑色节点数量，也就是最短路径的两倍，也就是能保证时间复杂度始终保持在log级别，二叉树不会退化成链表\r\n旋转\r\n在几乎所有的平衡树中都很重要的操作。\r\n分为左旋转和右旋转，左旋转指的是将某个节点旋转为它右孩子的左孩子，右旋转指的是将某个节点旋转为它左孩子的右孩子，不难发现两个旋转是互逆的操作。\r\n那么以右旋为例，说明如何完成旋转操作，这里假设当前节点是RT,其左儿子是X:\r\n\r\n将RT的左孩子指针指向X的右孩子\r\n将X的右孩子引用指向RT，完成旋转\r\n\r\n不难发现两个旋转都不会对树的性质产生破坏。\r\n在学习的时候发现实现过程没有想象中那么变态哈哈哈哈。\r\n插入\r\n首先参考二叉搜索树，前期过程基本相似，但插入后需要进行调整。\r\n假设当前节点now，父亲节点fa，祖父节点g，叔叔节点u（由于是二叉树所以最多只有一个叔叔节点），会有五种情况\r\n新节点是根节点\r\n直接插入，注意now颜色是黑色\r\nfa是黑色\r\nnow颜色是红色，其他的无需调整\r\nfa是红色，u是红色\r\nnow是红色，将fa和u染为黑色，G染为红色，注意到G的父亲可能是红色，所以需要递归向上染色知道不出现连续的两个红色节点。\r\nfa是红色，u是黑色，now是左孩子\r\n那么G一定是黑色，此时对G进行右旋，调整fa和g的位置然后互换颜色，也就是G变红，fa变黑。\r\nfa是红色，u是黑色，now是右孩子\r\n对fa进行左旋，然后fa变成了now，now变成了fa并且此时now一定是左孩子，那么之后的处理同上即可。\r\n删除\r\n依旧一样，前面步骤同普通BST。\r\n而复杂的，依旧是对于颜色红黑变换的处理问题。\r\n可以观察到由于是对后继原来的位置进行删除操作，那么这个时候被删除的那个位置只存在右子树。\r\n一下是对情况的分类，为了方便说明，这里将当前节点设为now，父亲节点为fa，祖父节点为g，叔叔节点为u，孩子节点为k，兄弟节点bro，bro左孩子节点bl，右孩子节点br。\r\n注意这里fa和now之间本来的节点已经被删除，now现在是顶替上去的那一位。\r\n被删除的是红色（再下面的情况默认被删除的是黑色）\r\n和BST一致操作即可\r\nk是红色（再下面情况默认now和k都是黑色）\r\n只需要将k染色为黑色即可\r\nk是整棵树新的根\r\n那么实际上已经完成了删除操作\r\nfa是红色，bro和bro的孩子是黑色\r\n只需要交换fa和bro的颜色即可。\r\nbro是黑色，bl红色，br黑色，fa无所谓，now是fa的左孩子\r\n对bro进行右旋操作，互换bro和bl的颜色，将树调换成了下一种情况的样子，继续讨论\r\nbro是黑色，br红色，fa无所谓，now是fa的左孩子\r\n对fa进行左旋，互换fa和bro的颜色，将br变为黑色\r\nbro为红色，其他为黑\r\n对fa进行左旋，调换fa和bro的颜色，但是修改仍未完成，但是我们将这种情况转化为了上述情况之一。\r\n代码实现\r\n看看主播什么时候能根据算法导论和维基百科搓出来\r\n主播放弃了，目前的代码是这样的\r\n目前的删除环节仍然存在一定的问题。\r\n#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;typedef enum&#123;RED,BLACK&#125;COLOR;typedef struct RBnode&#123;    int val,cnt;    struct RBnode* lkid;    struct RBnode* rkid;    struct RBnode* fa;    COLOR color;&#125;RBnode;//建点 typedef struct &#123;    struct RBnode* root;&#125;RBtree;//建树 inline RBnode* Init()&#123;//新创建一个节点     RBnode* now= (RBnode*)malloc(sizeof(RBnode));    now-&gt;color=RED;    now-&gt;lkid=NULL;    now-&gt;rkid=NULL;    now-&gt;fa=NULL;    now-&gt;cnt=1;    return now;&#125;inline RBnode* Left_Rotate(RBnode* now)&#123;    RBnode* father=now-&gt;fa;    RBnode* grand=father-&gt;fa;    father-&gt;rkid=now-&gt;lkid;    if (father-&gt;rkid!=NULL) father-&gt;rkid-&gt;fa=father;    now-&gt;lkid=father;    father-&gt;fa=now;    grand-&gt;lkid=now;    now-&gt;fa=grand;    return now;&#125;inline RBnode* Right_Rotate(RBnode* now)&#123;    RBnode* father=now-&gt;fa;    RBnode* grand=father-&gt;fa;    father-&gt;lkid=now-&gt;rkid;    if (father-&gt;lkid!=NULL) father-&gt;lkid-&gt;fa=father;    now-&gt;rkid=father;    father-&gt;fa=now;    grand-&gt;rkid=now;    now-&gt;fa=grand;    return now;&#125;inline void insert_adjust(RBtree* ptree,RBnode* now)&#123;    //虽然失衡才进入，但是还是特判是否失衡    if (now-&gt;fa!=NULL &amp;&amp; now-&gt;fa-&gt;color==BLACK) return;    //只有根节点，染黑即可    if (now-&gt;fa==NULL)&#123;        now-&gt;color=BLACK;        return;    &#125;     //不是root    RBnode* father=now-&gt;fa;    RBnode* grand=father-&gt;fa;    RBnode* uncle;    if (grand-&gt;lkid==father) uncle=grand-&gt;rkid;    else uncle=grand-&gt;lkid;    //uncle是红色，叔父爷变色，调整为其他情况    if (uncle!=NULL &amp;&amp; uncle-&gt;color==RED)&#123;        uncle-&gt;color=BLACK;        father-&gt;color=BLACK;        grand-&gt;color=RED;        insert_adjust(ptree,grand);        return;    &#125;    //叔叔是黑色或空    if (grand-&gt;lkid==father)&#123;        if (father-&gt;lkid==now)&#123;//LL            father-&gt;color=BLACK;            grand-&gt;color=RED;            RBnode* great=grand-&gt;fa;            RBnode* ptr=Right_Rotate(now);            //获取太爷，右旋             if (great==NULL)&#123;                ptree-&gt;root=ptr;                ptr-&gt;fa=NULL;                return;            &#125;else&#123;                if (ptr-&gt;val &lt; great-&gt;val) great-&gt;lkid=ptr;                else great-&gt;rkid=ptr;                ptr-&gt;fa=great;            &#125;            return;        &#125;else&#123;//LR            //左旋后处理冲突             father-&gt;rkid=now-&gt;lkid;             if (father-&gt;rkid!=NULL) father-&gt;rkid-&gt;fa=father;             now-&gt;lkid=father;             father-&gt;fa=now;             grand-&gt;lkid=now;             now-&gt;fa=grand;             //变色然后右旋             grand-&gt;color=RED;             now-&gt;color=BLACK;             RBnode* great=grand-&gt;fa;             RBnode* ptr=Right_Rotate(father);             if (great==NULL)&#123;                 ptree-&gt;root=ptr;                 ptr-&gt;fa=NULL;                 return;             &#125;else&#123;                 if (ptr-&gt;val &lt; great-&gt;val) great-&gt;lkid=ptr;                 else great-&gt;rkid=ptr;                 ptr-&gt;fa=great;             &#125;             return;        &#125;    &#125;    if (grand-&gt;rkid==father)&#123;//R        if (father-&gt;rkid==now)&#123;//RR            father-&gt;color=BLACK;            grand-&gt;color=RED;            RBnode* great=grand-&gt;fa;            RBnode* ptr=Left_Rotate(now);            if (great==NULL)&#123;                ptree-&gt;root=ptr;                ptr-&gt;fa=NULL;                return;            &#125;else&#123;                 if (ptr-&gt;val &lt; great-&gt;val) great-&gt;lkid=ptr;                 else great-&gt;rkid=ptr;                 ptr-&gt;fa=great;            &#125;            return;        &#125;else&#123;//RL            father-&gt;lkid=now-&gt;rkid;            if (father-&gt;lkid!=NULL) father-&gt;lkid-&gt;fa=father;            now-&gt;rkid=father;            father-&gt;fa=now;            grand-&gt;rkid=now;            now-&gt;fa=grand;            grand-&gt;color=RED;            now-&gt;color=BLACK;            RBnode* great=grand-&gt;fa;            RBnode* ptr=Left_Rotate(father);            if (great==NULL)&#123;                ptree-&gt;root=ptr;                ptr-&gt;fa=NULL;                return;            &#125;else&#123;                 if (ptr-&gt;val &lt; great-&gt;val) great-&gt;lkid=ptr;                 else great-&gt;rkid=ptr;                 ptr-&gt;fa=great;            &#125;            return;        &#125;    &#125;&#125;inline RBnode* Search(RBtree* ptree,int val)&#123;    RBnode* p=ptree-&gt;root;    while (p!=NULL &amp;&amp; p-&gt;val!=val)&#123;        if (val &lt; p-&gt;val) p=p-&gt;lkid;        else p=p-&gt;rkid;    &#125;    return p;&#125;inline RBnode* search_front(RBtree* ptree,int val)&#123;    RBnode* p=ptree-&gt;root;    while (p!=NULL)&#123;        if (val &lt;= p-&gt;val) p=p-&gt;lkid;        else p=p-&gt;rkid;    &#125;    return p;&#125;inline RBnode* search_next(RBtree* ptree,int val)&#123;    RBnode* p=ptree-&gt;root;    while (p!=NULL)&#123;        if (val &lt; p-&gt;val) p=p-&gt;lkid;        else p=p-&gt;rkid;    &#125;    return p;&#125;inline void delete_adjust(RBtree* ptree,RBnode* node,bool tag)&#123;    //1.申请多个指针分别用于指向其父节点和兄弟节点以及自己的孩子节点    RBnode* father = node-&gt;fa;    RBnode* sibling = NULL;    RBnode* child = node-&gt;lkid != NULL ? node-&gt;lkid : node-&gt;rkid;//node节点自身的孩子    //2.分情况处理    //待删除节点只有左孩子/只有右孩子    if (tag &amp;&amp; (node-&gt;lkid != NULL || node-&gt;rkid != NULL))&#123;        //若待删除节点的父节点不存在，说明当前单分支节点是根节点        if (father == NULL)&#123;            //让辅助节点抓住它的儿子            ptree-&gt;root = child;        &#125;        else//这个节点不是根节点，那就让它爸来接收它的儿子        &#123;            if (child-&gt;val &lt; father-&gt;val)                father-&gt;lkid = child;            else                father-&gt;rkid = child;        &#125;        child-&gt;fa = father;        child-&gt;color = BLACK;        free(node);        return;    &#125;    else//零分支：此时待删除节点没有孩子    &#123;        if (tag &amp;&amp; (father == NULL))//如果待删除节点没有孩子，且它爸也不在，则无需判断颜色，直接删除        &#123;            ptree-&gt;root = NULL;            free(node);            return;        &#125;        else//它爸在的话，要判断当前没有孩子的节点的颜色了        &#123;            if (tag &amp;&amp; (node-&gt;color == RED))//当前待删除节点node颜色是红色             &#123;                //别忘了，让抓着待删除节点的父节点的相应的孩子指针指向NULL                if (father-&gt;lkid == node)                    father-&gt;lkid = NULL;                else                    father-&gt;rkid = NULL;                //释放当前待删除节点，无需调整                free(node);                return;            &#125;            else//待删除节点没有孩子，但是有双亲，且颜色是黑色             &#123;                //申请一个指针sibling用来指向其兄弟节点                sibling = (node == father-&gt;lkid) ? father-&gt;rkid : father-&gt;lkid;                RBnode* grandfather = father-&gt;fa;//有可能为NULL，它爷爷是有可能不存在的                if (sibling-&gt;color == RED)//兄弟节点是红色                &#123;                    //父兄变色                    sibling-&gt;color = BLACK;                    father-&gt;color = RED;                    //当前的父节点朝着待删除节点(双黑节点)一侧进行单旋                    RBnode* ptr = father-&gt;lkid == node ? Left_Rotate(sibling-&gt;rkid) : Right_Rotate(sibling-&gt;lkid);                    //此时，根据grandfather的存在与否，来接收旋转之后的返回值                    if (grandfather == NULL)                    &#123;                        ptree-&gt;root = ptr;                    &#125;                    else                    &#123;                        if (ptr-&gt;val &lt; grandfather-&gt;val)                            grandfather-&gt;lkid = ptr;                        else                            grandfather-&gt;rkid = ptr;                    &#125;                    ptr-&gt;fa = grandfather;                    //此时，待删除节点出现新的兄弟节点，重新进行逻辑判断                    delete_adjust(ptree, node, tag);//bug 第二个参数有可能是需要删除，有可能是不需要删的 //******                    return;                &#125;                else//兄弟节点是黑色                &#123;                    //此时情况下，兄弟节点是黑色，不管有没有红色孩子，当前待删除节点后续都不                    //再需要它了，所以此时可以提前把它释放带哦                    if (tag)                    &#123;                        if (father-&gt;lkid == node)                            father-&gt;lkid = NULL;                        else                            father-&gt;rkid = NULL;                        free(node);                    &#125;                    //这种情况下，再分兄弟节点有没有红孩                    RBnode* redchild = NULL;                    if (sibling-&gt;lkid != NULL &amp;&amp; sibling-&gt;lkid-&gt;color == RED)                    &#123;                        redchild = sibling-&gt;lkid;                    &#125;                    else if (sibling-&gt;rkid != NULL &amp;&amp; sibling-&gt;rkid-&gt;color == RED)                    &#123;                        redchild = sibling-&gt;rkid;                    &#125;                    else                    &#123;                        redchild = NULL;                    &#125;                    //判断redchild是否是NULL                    //兄弟没有一个红孩                    if (redchild == NULL)                    &#123;                        //兄弟变红                        sibling-&gt;color = RED;                        //双黑上移，双黑节点移动到父节点位置                        if (father-&gt;fa == NULL || father-&gt;color == RED)                        &#123;                            father-&gt;color = BLACK;                            return;                        &#125;                        //不然双黑上移：遇到的节点不是根节点，且是黑色                        delete_adjust(ptree, father, false);                        return;                    &#125;                    else//至少有一个红孩                    &#123;                        //判断兄弟，兄弟他爸，兄弟红色孩子三者型号，调用对应旋转                        if (father-&gt;lkid == sibling)//L                        &#123;                            if (sibling-&gt;lkid == redchild)//LL  // bug 两个等于号又写成一个等于号了                             &#123;                                //先变色，r变s，s变p，p变黑                                redchild-&gt;color = sibling-&gt;color;                                sibling-&gt;color = father-&gt;color;                                father-&gt;color = BLACK;                                //需要单右旋，旋转点是father，绕着兄弟节点转(旋转中心点是sibling)                                RBnode* grandfather = father-&gt;fa;                                RBnode* ptr = Right_Rotate(redchild);                                if (grandfather == NULL)                                &#123;                                    ptree-&gt;root = ptr;                                    ptr-&gt;fa = NULL;                                &#125;                                else                                &#123;                                    if (ptr-&gt;val &lt; grandfather-&gt;val)                                        grandfather-&gt;lkid = ptr;                                    else                                        grandfather-&gt;rkid = ptr;                                    ptr-&gt;fa = grandfather;                                &#125;                                return;                            &#125;                            else//LR                            &#123;                                //先变色，r变p，p变黑                                redchild-&gt;color = father-&gt;color;                                father-&gt;color = BLACK;                                //先左旋                                //先处理冲突节点                                sibling-&gt;rkid = redchild-&gt;lkid;                                if (sibling-&gt;rkid != NULL)                                &#123;                                    sibling-&gt;rkid-&gt;fa = sibling;                                &#125;                                redchild-&gt;lkid = sibling;                                sibling-&gt;fa = redchild;                                father-&gt;lkid = redchild;                                redchild-&gt;fa = father;                                //再右旋                                RBnode* grandfather = father-&gt;fa;                                RBnode* ptr = Right_Rotate(sibling);                                if (grandfather == NULL)                                &#123;                                    ptree-&gt;root = ptr;                                    ptr-&gt;fa = NULL;                                &#125;                                else                                &#123;                                    if (ptr-&gt;val &lt; grandfather-&gt;val)                                        grandfather-&gt;lkid = ptr;                                    else                                        grandfather-&gt;rkid = ptr;                                    ptr-&gt;fa = grandfather;                                &#125;                                return;                            &#125;                        &#125;                        if (father-&gt;rkid == sibling)//R                        &#123;                            if (sibling-&gt;rkid != NULL &amp;&amp; sibling-&gt;rkid-&gt;color == RED)//RR                            &#123;                                redchild = sibling-&gt;rkid;                                //先变色 r变s，s变r，p变黑                                redchild-&gt;color = sibling-&gt;color;                                sibling-&gt;color = father-&gt;color;                                father-&gt;color = BLACK;                                //单左旋                                RBnode* grandfather = father-&gt;fa;                                RBnode* ptr = Left_Rotate(redchild);                                if (grandfather == NULL)                                &#123;                                    ptree-&gt;root = ptr;                                    ptr-&gt;fa = NULL;                                &#125;                                else                                &#123;                                    if (ptr-&gt;val &lt; grandfather-&gt;val)                                        grandfather-&gt;lkid = ptr;                                    else                                        grandfather-&gt;rkid = ptr;                                    ptr-&gt;fa = grandfather;                                &#125;                                return;                            &#125;                            else//RL                            &#123;                                //先变色 r变s，p变黑                                redchild-&gt;color = father-&gt;color;                                father-&gt;color = BLACK;                                //先右旋                                //先处理冲突节点                                sibling-&gt;lkid = redchild-&gt;rkid;                                if (sibling-&gt;lkid != NULL)                                &#123;                                    sibling-&gt;lkid-&gt;fa = sibling;                                &#125;                                redchild-&gt;rkid = sibling;                                sibling-&gt;fa = redchild;                                father-&gt;rkid = redchild;                                redchild-&gt;fa = father;                                //再左旋                                RBnode* grandfather = father-&gt;fa;                                RBnode* ptr = Left_Rotate(sibling);                                if (grandfather == NULL)                                &#123;                                    ptree-&gt;root = ptr;                                    ptr-&gt;fa = NULL;                                &#125;                                else                                &#123;                                    if (ptr-&gt;val &lt; grandfather-&gt;val)                                        grandfather-&gt;lkid = ptr;                                    else                                        grandfather-&gt;rkid = ptr;                                    ptr-&gt;fa = grandfather;                                &#125;                                return;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125; inline void Delete(RBtree* ptree,int val)&#123;    RBnode* now=Search(ptree,val);    now-&gt;val=now-&gt;val-1;    if (now-&gt;val!=0) return;    if (now-&gt;lkid==NULL &amp;&amp; now-&gt;rkid==NULL) delete_adjust(ptree,now,1);    RBnode* Next=search_next(ptree,val);    RBnode* father=now-&gt;fa;    if (now==father-&gt;lkid)&#123;        father-&gt;lkid=Next;        if (Next-&gt;fa-&gt;lkid==Next)&#123;            Next-&gt;fa-&gt;lkid=Next-&gt;rkid;            Next-&gt;rkid-&gt;fa=Next-&gt;fa;        &#125;else&#123;            Next-&gt;fa-&gt;rkid=Next-&gt;rkid;            Next-&gt;rkid-&gt;fa=Next-&gt;fa;        &#125;        Next-&gt;fa=father;    &#125;else&#123;        father-&gt;rkid=Next;        if (Next-&gt;fa-&gt;lkid==Next)&#123;            Next-&gt;fa-&gt;lkid=Next-&gt;rkid;            Next-&gt;rkid-&gt;fa=Next-&gt;fa;        &#125;else&#123;            Next-&gt;fa-&gt;rkid=Next-&gt;rkid;            Next-&gt;rkid-&gt;fa=Next-&gt;fa;        &#125;        Next-&gt;fa=father;    &#125;    free(now);    delete_adjust(ptree,Next,1);&#125;inline void insert(RBtree* ptree,int val)&#123;//插入一个节点     RBnode* now=Init();    now-&gt;val=val;    RBnode* p=ptree-&gt;root;    RBnode* pp=NULL;    if (p==NULL)&#123;//空树直接建根         ptree-&gt;root=now;        now-&gt;color=BLACK;        return;    &#125;    while (p!=NULL &amp;&amp; p-&gt;val!=val)&#123;        pp=p;        if (val &lt; p-&gt;val) p=p-&gt;lkid;        else p=p-&gt;rkid;    &#125;//查找应该插入的位置    if (p!=NULL)&#123;//已经存在该节点         p-&gt;cnt=p-&gt;cnt + 1;        free(now);        return;    &#125;    //不存在该节点，需要插入，注意pp是父亲     if (val&lt;pp-&gt;val) pp-&gt;lkid=now;    else pp-&gt;rkid=now;    now-&gt;fa=pp;    if (pp-&gt;color==RED) insert_adjust(ptree,now);    //违反性质，连续两个红色了，失衡 &#125;int main()&#123;    return 0;&#125;\r\n好吧先鸽着，以后再碰到什么想不开的事情再来填坑.\r\nSplay平衡树\r\n基本操作\r\n顾名思义，splay的中文是伸展，而伸展操作中，最重要的是旋转，正巧和上文红黑树中的左旋和右旋是一样的意思，并且旋转之后中序遍历不变，BST性质保持。那么接下来就是伸展。伸展就是通过旋转，将一个节点转移到另外一个节点的下方。比如Splay(x,k)就是把x转到k的下方，特殊的Splay(x,0)是把x转到根。不难发现k应该是x的祖先。\r\n下面说明伸展的具体步骤，这边就已Splay(x,k)为例说明 ：\r\n\r\nx的父亲是k，那么已经满足条件\r\nx的爷爷是k，只需要一次旋转。x是左儿子就右旋，x是右儿子就左旋。\r\nx的父亲和爷爷都不是k但是x和他的父亲和爷爷共线，只要先旋转父亲，再旋转自己然后一直向上递归直到结束即可\r\n不共线。只要连续转两次即可，如果x是左儿子就右旋，x是右儿子就左旋\r\n\r\nSplay\r\n一个好习惯是进行对一个节点操作之后就Splay该节点到根节点。\r\n哨兵\r\n为了防止边界情况，使用INF和-INF作为树的哨兵防止越界。\r\n查找\r\n只要按照BST的性质向下查找即可。\r\n然后将当前节点换至根节点。\r\n前驱&amp;后继\r\n和红黑树中描述一样，前驱是左子树中最大的，后继是右子树中最小的。\r\n插入\r\n查找到需要插入的位置插入，然后将新元素旋转到根。\r\n删除\r\n不难发现在splay中，叶子结点的删除会简单很多，那么也就是要将节点变成叶子节点然后删除。\r\n这里有一个很好的思路，使用一个节点的前驱和后继，前驱做根，后继做右节点，那么当前节点右子树的左子树有且只有一个节点也就是要被删除的节点。（哨兵除外）\r\n排名\r\n显然是一个节点作为根之后左子树的大小.（别忘了还有一个哨兵）\r\n查询排名为rank的数值\r\n从根节点枚举，根据左子树大小和根节点数字个数来判断往哪里递归或是结束递归。\r\n可以使用数组模拟链表，实现难度相比红黑树小很多。（问题的种类数少很多。）\r\nP3369\r\n【模板】普通平衡树 - 洛谷\r\n然后经过博主一天的奋斗，终于是第一遍完全靠自己理解打出了这个沟槽的板子，非常开心\r\n#include&lt;cstdio&gt;#include&lt;ctype.h&gt;using namespace std;const int N=100005,INF=1&lt;&lt;30;int root=0,node_cnt;struct SPLAY&#123;    int son[2],fa,cnt,sum,val;    void Init(int p,int w)&#123;        fa=p;val=w;        sum=1;cnt=1;    &#125;&#125;tr[N];inline int read()&#123;    int x=0;char ch=getchar();bool flag=1;    while (!isdigit(ch))&#123;        if (ch==&#x27;-&#x27;) flag=0;        ch=getchar();    &#125;    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    if (flag) return x;    return -x;&#125;inline void update(int x)&#123;    tr[x].sum=tr[ tr[x].son[0] ].sum+tr[ tr[x].son[1] ].sum+tr[x].cnt;&#125;inline void rotate(int x)&#123;    int father=tr[x].fa,grand=tr[father].fa;    bool now=(tr[father].son[1]==x);    //father和grandfather关系变化     tr[grand].son[tr[grand].son[1]==father]=x;    tr[x].fa=grand;    //x的子树移给father     tr[father].son[now]=tr[x].son[now^1];    tr[tr[x].son[now^1]].fa=father;    //x旋转到father的位置    tr[father].fa=x;    tr[x].son[now^1]=father;    update(father);update(x); &#125;inline void Splay(int x,int k)&#123;    while (tr[x].fa!=k)&#123;        int father=tr[x].fa,grand=tr[father].fa;        if (grand!=k)            if ((tr[father].son[0]==x)^(tr[grand].son[0]==father)) rotate(x);            else rotate(father);//第一个条件直线，第二个不呈直线         rotate(x);    &#125;    if (k==0) root=x;&#125;inline void Insert(int w)&#123;    int rt=root,ptr=0;    while (rt &amp;&amp; tr[rt].val!=w)&#123;        ptr=rt;        rt=tr[rt].son[w&gt;tr[rt].val];    &#125;    if (rt) tr[rt].cnt++;    else&#123;        rt=++node_cnt;        tr[ptr].son[w&gt;tr[ptr].val]=rt;        tr[rt].Init(ptr,w);    &#125;    Splay(rt,0);&#125;inline void find(int w)&#123;    int rt=root;    while (tr[rt].son[w&gt;tr[rt].val] &amp;&amp; tr[rt].val!=w) rt=tr[rt].son[w&gt;tr[rt].val];    Splay(rt,0);&#125;inline int PRE(int w)&#123;    find(w);    int rt=root;    if (w&gt;tr[rt].val) return rt;    rt=tr[rt].son[0];    while (tr[rt].son[1]) rt=tr[rt].son[1];    Splay(rt,0);    return rt;&#125;inline int NXT(int w)&#123;    find(w);    int rt=root;    if (w&lt;tr[rt].val) return rt;    rt=tr[rt].son[1];    while (tr[rt].son[0]) rt=tr[rt].son[0];    Splay(rt,0);    return rt;&#125;inline void Delete(int w)&#123;    int pre=PRE(w),nxt=NXT(w);    Splay(pre,0);Splay(nxt,pre);    int now=tr[nxt].son[0];    if (tr[now].cnt&gt;1)&#123;        tr[now].cnt--;        Splay(now,0);    &#125;else&#123;        tr[nxt].son[0]=0;        Splay(nxt,0);    &#125;&#125;inline int query_rank(int w)&#123;    Insert(w);    int res=tr[tr[root].son[0]].sum;    Delete(w);    return res;&#125;inline int query_val(int loc)&#123;    int rt=root;    while (1)&#123;        if (loc&lt;=tr[tr[rt].son[0]].sum) rt=tr[rt].son[0];        else if (loc&lt;=tr[tr[rt].son[0]].sum+tr[rt].cnt) break;        else&#123;            loc-=tr[tr[rt].son[0]].sum+tr[rt].cnt;            rt=tr[rt].son[1];        &#125;    &#125;    Splay(rt,0);    return tr[rt].val;&#125;int main()&#123;    int T=read();    Insert(INF);Insert(-INF);    while (T--)&#123;        char opt=read();        if (opt==1)&#123;            int x=read();            Insert(x);        &#125;else if (opt==2)&#123;            int x=read();            Delete(x);        &#125;else if (opt==3)&#123;            int x=read();            printf(&quot;%d\\n&quot;,query_rank(x));        &#125;else if (opt==4)&#123;            int x=read();            printf(&quot;%d\\n&quot;,query_val(x+1));        &#125;else if (opt==5)&#123;            int x=read();            printf(&quot;%d\\n&quot;,tr[PRE(x)].val);        &#125;else if (opt==6)&#123;            int x=read();            printf(&quot;%d\\n&quot;,tr[NXT(x)].val);        &#125;    &#125;    return 0;&#125;\r\n红黑树真的有点力竭了，目前是删除还存在一些问题，只能过两个点\r\nTreap\r\n=tree+heap这里埋一个坑，博主今天不想做平衡树了\r\n暂时完结撒花！后续treap应该会单开一文，红黑树再更新也会单开一文。\r\nAnyway，总算是学会了一直觉得很吊的平衡树！\r\n再见咯，十月五号\r\n\r\n\r\n","categories":["学习"],"tags":["C++","数据结构","平衡树，模板"]},{"title":"P4735 最大异或和","url":"/2025/10/05/P4735-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/","content":"题目大意\r\n传送门(题面简洁明了)\r\n\r\n两种做法，可持久化trie树，离线+trie树前一种还没学，所以用了lowlow的第二种\r\n总体来说就是先离线排序出加入的顺序，根据询问建树，一边建树一边回答询问最终将答案按照原定顺序输出，在trie树上维护经过此点的最大区间下标即可，这样就可以判断是否在给出区间的左边界之后了。trie树建树就是常规的01trie前缀和建树转化区间求前缀的思路。\r\n非常重要！以后在出现函数的时候不要想着玩类似++cnt或者cnt++的把戏，非常容易出错！多打一行代码不会死。\r\n下面上代码\r\n#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#include&lt;algorithm&gt;using namespace std;const int LEN=6000005,N=600005;int n,m,tot=1,cnt,a[N],ans[N],tr[LEN][2],sec[LEN][2];struct XOR&#123;    int l,r,x,now,id;    XOR()&#123;&#125;    XOR(int L,int R,int X,int NOW,int ID): l(L),r(R),x(X),now(NOW),id(ID)&#123;&#125;&#125;b[N];inline int read()&#123;    int x=0;char ch=getchar();    while (!isdigit(ch)) ch=getchar();    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    return x;&#125;inline bool cmp(XOR a,XOR b)&#123;return a.r&lt;b.r;&#125;inline void insert(int x,int loc)&#123;    for (int i=25,rt=1;~i;i--)&#123;        bool now=(x&gt;&gt;i)&amp;1;        if (!tr[rt][now]) tr[rt][now]=++tot;        sec[rt][now]=loc;        rt=tr[rt][now];    &#125;&#125;inline int query(int x,int loc)&#123;    int res=0;    for (int i=25,rt=1;~i;i--)&#123;        bool now=(x&gt;&gt;i)&amp;1;        if (tr[rt][now^1] &amp;&amp; sec[rt][now^1]&gt;=loc)&#123;            res|=1&lt;&lt;i;            rt=tr[rt][now^1];        &#125;else rt=tr[rt][now];    &#125;    return res;&#125;int main()&#123;    n=read();m=read();    for (int i=1;i&lt;=n;i++) a[i]=read();    for (int i=1;i&lt;=m;i++)&#123;        char ch=getchar();        while (ch!=&#x27;A&#x27; &amp;&amp; ch!=&#x27;Q&#x27;) ch=getchar();        if (ch==&#x27;A&#x27;) a[++n]=read();        else&#123;            int l=read(),r=read(),x=read();            cnt++;            b[cnt]=XOR(l,r,x,n,cnt);        &#125;    &#125;    for (int i=n;i;i--) a[i]^=a[i+1];    sort(b+1,b+cnt+1,cmp);    for (int i=1,ptr=1;i&lt;=cnt;i++)&#123;        while (ptr&lt;=b[i].r)&#123;            insert(a[ptr],ptr);            ptr++;        &#125;        ans[b[i].id]=query(a[b[i].now+1]^b[i].x,b[i].l);    &#125;    for (int i=1;i&lt;=cnt;i++) printf(&quot;%d\\n&quot;,ans[i]);    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","trie树"]},{"title":"P3435 [POI 2006] OKR-Periods of Words","url":"/2025/10/03/P3435-POI-2006-OKR-Periods-of-Words/","content":"题目大意\r\n题目定义了一个“最大周期”，也就是长度最大的一个符合条件的字符串前缀，原字符串是该前缀两倍的前缀。要求求出所有前缀的最大周期长度之和。（不存在最大周期即长度为0）\r\n\r\n再一次更加明白了KMP的内涵吧。对于进行到第i位而言，只要存在前缀和后缀相同，也就是kmp[i]存在，那么显然一定存在最大周期，要想周期最大，那么显然是该字符串最短后缀的前半部分，因为最短后缀的前半部分重复两遍必然构成符合条件的字符串，且因为后缀最短，此时求出的一定是最大周期，那么只要先求出kmp，再根据kmp的性质，递归求出最短后缀（其实也就是前缀）的长度就好了，最后用一个小trick，学习了一下并查集的路径压缩，就可以进一步压缩时间复杂度，大概是O(nlog*n)还是蛮优秀的复杂度\r\n#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N=1000005;int len,kmp[N];char s[N];inline int find(int j)&#123;\tif (kmp[j]) return kmp[j]=find(kmp[j]);\treturn j;&#125;int main()&#123;\tscanf(&quot;%d%s&quot;,&amp;len,s+1);\tfor (int i=2,j=0;i&lt;=len;i++)&#123;\t\twhile (j &amp;&amp; s[j+1]!=s[i]) j=kmp[j];\t\tif (s[j+1]==s[i]) j++;\t\tkmp[i]=j;\t&#125;\tlong long ans=0;\tfor (int i=2,j=2;i&lt;=len;i++,j=i)&#123;\t\tj=find(j);\t\tans+=i-j;\t&#125;\tprintf(&quot;%lld\\n&quot;,ans);\treturn 0;&#125; \r\n代码还是蛮简短明了的，再见咯，十月三号。\r\n\r\n\r\n","categories":["学习"],"tags":["C++","KMP"]},{"title":"20251003小记","url":"/2025/10/03/20251003%E5%B0%8F%E8%AE%B0/","content":"首先是以后学习一定要注意细节！！！昨天一个代码只是因为一开始输入的时候大意了多打了一个n–，没有很好的理清关系，以为是主体部分出错导致调试了近两个半小时，非常不值当且让人心态爆炸，一定要注意以后。\r\n然后是很开心！又有一个室友昨天回来了哈哈哈哈寝室里呆着就没有那么孤独。以及昨天好久不见的初中哥们Wu同学来成都玩！srds吐槽一下绿皮计划五点半到达，但是接到人的时候已经八点了，等了非常久且肚子饿饿TAT.但是！晚上吃的火锅真的很满足哈哈哈哈哈但是大出血了当时太晚了很多烟火小店关门了只能到大店吃性价比真的一般打车回学校之后室友还没睡！并且后来和Wang同学激情电话（当然了没有在寝室里不要喷博主emm）非常快乐地就熬到了今天早上的凌晨，和室友吃了麦麦早餐之后就把他送走了（哥们旅游去了）。今天倒是平平淡淡没发生啥事，打扫了一下寝室的卫生履行一下这个”寝室长”的职责哈哈哈哈哈哈，重新开始我省钱的泡面计划哈哈哈哈哈哈，今日跑步休息一天因为膝盖的问题，明天继续。\r\n\r\n\r\n\r\n","categories":["日记"],"tags":["碎碎念"]},{"title":"P2375 [NOI2014] 动物园","url":"/2025/10/03/P2375-NOI2014-%E5%8A%A8%E7%89%A9%E5%9B%AD/","content":"题目大意\r\n这篇题目的描述实在是废话太多了\r\n对于N个字符串，求出从头开始到i(1 ≤ i ≤ n)结束的时候每一次前缀等于后缀的数量\r\n并且前后缀不能重合\r\n比如字符串aaaa，i=4时，就有a和aa两个前后缀符合这个特点\r\n\r\n总体思路\r\nKMP+DP\r\n先抛开前缀后缀不重叠的限制\r\nKMP可以求出到第i位时最长的一致前缀和后缀，那么考虑每一个一致的前缀和后缀\r\n不难发现这时某一个字符串拥有的数量一定是他最长一致前后缀拥有的数量+1也就是多出了最长一致前后缀本身的那一组。\r\n剩下的就很简单了，\r\n由于一致前后缀的一致前后缀一定是一致前后缀\r\n(a是aa的一致前后缀，aa是aaaa的一致前后缀，a显然是aaaa的一致前后缀)\r\n只需要在累乘的时候不断地将指针跳到KMP算法求出的前一个位置，直到小于当前长度的一半，此时DP数组的值就是当前的一致前后缀数量。\r\n细节看代码，模数较大的时候一定要开long long\r\n#include&lt;cstdio&gt;#include&lt;cstring&gt;#define int long longusing namespace std;const int mod=1000000007,N=1000005;int kmp[N],sum[N];char s[N];signed main()&#123;\tint T;scanf(&quot;%lld&quot;,&amp;T);\twhile (T--)&#123;\t\tmemset(kmp,0,sizeof(kmp));\t\tmemset(sum,0,sizeof(sum));\t\tsum[1]=1;\t\tscanf(&quot;%s&quot;,s+1);\t\tint len=strlen(s+1),j=0;\t\tfor (int i=2;i&lt;=len;i++)&#123;\t\t\twhile (j &amp;&amp; s[j+1]!=s[i]) j=kmp[j];\t\t\tif (s[j+1]==s[i]) j++;\t\t\tkmp[i]=j;sum[i]=sum[j]+1;\t\t&#125;\t\tj=0;int ans=1;\t\tfor (int i=2;i&lt;=len;i++)&#123;\t\t\twhile (j &amp;&amp; s[j+1]!=s[i]) j=kmp[j];\t\t\tif (s[j+1]==s[i]) j++;\t\t\twhile (i&lt;(j&lt;&lt;1)) j=kmp[j];\t\t\tans=(ans*(sum[j]+1))%mod;\t\t&#125;\t\tprintf(&quot;%lld\\n&quot;,ans);\t&#125;\treturn 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","KMP","DP"]},{"title":"P2922 [USACO08DEC] Secret Message G","url":"/2025/10/03/P2922-USACO08DEC-Secret-Message-G/","content":"题目大意：\r\n给出两组01串组，求问后面一组是前面的前缀或后缀的数量\r\n01trie树板子题，注意两串相等的情况即可\r\n\r\n#include&lt;cstdio&gt;using namespace std;const int N=50005;int n,m,tot,trie[500005][2],siz[500005],End[500005];bool M[N];inline void insert(int T,int rt=0)&#123;    for (int i=0;i&lt;T;i++)&#123;        siz[rt]++;        bool now=M[i];        if (!trie[rt][now]) trie[rt][now]=++tot;        rt=trie[rt][now];    &#125;    siz[rt]++;End[rt]++;&#125;inline int query(int T,int rt=0)&#123;    int res=0;    for (int i=0;i&lt;T;i++)&#123;        res+=End[rt];        bool now=M[i];        if (trie[rt][now]) rt=trie[rt][now];        else return res;    &#125;    return res+siz[rt];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for (int i=1;i&lt;=m;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        for (int j=0;j&lt;x;j++)&#123;            char ch=getchar();            while (ch!=&#x27;0&#x27; &amp;&amp; ch!=&#x27;1&#x27;) ch=getchar();            M[j]=ch-&#x27;0&#x27;;        &#125;        insert(x);    &#125;    for (int i=1;i&lt;=n;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        for (int j=0;j&lt;x;j++)&#123;            char ch=getchar();            while (ch!=&#x27;0&#x27; &amp;&amp; ch!=&#x27;1&#x27;) ch=getchar();            M[j]=ch-&#x27;0&#x27;;        &#125;        printf(&quot;%d\\n&quot;,query(x));    &#125;    return 0;&#125;\r\n完结撒花★,°:.☆(￣▽￣)/$:.°★ 。\r\n\r\n\r\n","categories":["学习"],"tags":["C++","trie树"]},{"title":"luoguP5283 [十二省联考 2019] 异或粽子","url":"/2025/10/02/luoguP5283-%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%83-2019-%E5%BC%82%E6%88%96%E7%B2%BD%E5%AD%90/","content":"题目大意\r\n给出n个数的数列，要求找到k个组合[l,r]使这k个组合各个区间的异或后的和最大。\r\n\r\n整体思路\r\n首先鸽一下持久化trie树的做法，咳咳这个以后再说.本文介绍的是另一种实现简单一点的做法\r\n首先审题发现0 ≤ ai ≤ 4294967295，那么显然int的范围不够，千万不能因为细节丢分。\r\n那么首先根据题目中区间的设定和异或的性质很容易想到前缀”和”的想法。那么区间的异或值就可以O(1)求解了也就是sl − 1 ⊕ sr\r\n观察后可以发现一共有n2对组合，显然不能直接枚举，根据异或联想到01trie树可以log时间内解决区间第k大异或值的问题，那么问题就变成了:\r\n对于s0 − sn,构建一颗01trie树，并且先求出对于每一个si(0 ≤ i ≤ n)来说最优的sj，加入大根堆，这样出来的一定是第一大值，后续对于每次求出的最大值将对于该si来说的下一大值加入大根堆，这个贪心的思路可以保证每次取出的一定是当前最大值，并且由于01trie树的性质，每次取出的一定是不同的数列，除非i, j颠倒。\r\n那么对于i, j颠倒很好处理，显然如果i, j在答案队列中，j, i一定在答案中，那么只需要将原题中的k翻倍，这样选出来一定是完整的两对i, j，最后将ans折半输出即可，对于i = j的情况显然自己与自己的异或和是0，显然对答案不会有贡献。\r\n一个小坑\r\n博主在写trie树的时候总是容易忘记trie树的根是一个虚根，是无意义的，所以如果root = 1的话，记得trie树编号要从2开始！调了蛮久的。以及因为懒，直接define int long long\r\n了Emmmmm好像常数会大所以打了快读\r\n代码\r\n#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#define int long longusing namespace std;const int N=500005,TR=20000005;int n,k,tot=1,siz[TR],tr[TR][2],a[N];struct XOR&#123;    int id,rk,w;    XOR()&#123;&#125;    XOR(int x,int y,int z): id(x),rk(y),w(z)&#123;&#125;&#125;;inline bool operator &lt; (const XOR&amp; a,const XOR&amp; b)&#123;return a.w&lt;b.w;&#125;priority_queue&lt;XOR&gt; s;inline int read()&#123;    int x=0;char ch=getchar();    while (!isdigit(ch)) ch=getchar();    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    return x;&#125;inline void insert(int x,int rt=1)&#123;    siz[rt]++;    for (int i=31;~i;i--)&#123;        int now=(x&gt;&gt;i)&amp;1;        if (!tr[rt][now]) tr[rt][now]=++tot;        rt=tr[rt][now];        siz[rt]++;    &#125;&#125;inline int query(int x,int rk,int rt=1)&#123;    int res=0;    for (int i=31;~i;i--)&#123;        int now=(x&gt;&gt;i)&amp;1;        if (tr[rt][now^1])            if (rk&lt;=siz[tr[rt][now^1]])&#123;                res|=1ll&lt;&lt;i;                rt=tr[rt][now^1];            &#125;else&#123;                rk-=siz[tr[rt][now^1]];                rt=tr[rt][now];            &#125;        else rt=tr[rt][now];    &#125;    return res;&#125;signed main()&#123;    n=read();k=read()&lt;&lt;1;    insert(0);    for (int i=1;i&lt;=n;i++)&#123;        int x=read();        a[i]=a[i-1]^x;        insert(a[i]);    &#125;    for (int i=0;i&lt;=n;i++) s.push(XOR(i,1,query(a[i],1)));    int ans=0;    while (k--)&#123;        XOR now=s.top();s.pop();ans+=now.w;        if (now.rk&lt;n) s.push(XOR(now.id,now.rk+1,query(a[now.id],now.rk+1)));    &#125;    printf(&quot;%lld\\n&quot;,ans&gt;&gt;1);    return 0;&#125;\r\n完结撒花\r\n\r\n\r\n","categories":["学习"],"tags":["C++","trie树","luogu","STL"]},{"title":"struct重载运算符小记","url":"/2025/10/02/struct%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B0%8F%E8%AE%B0/","content":"结构体中的重构\r\n首先定义一个结构体\r\nstruct Example&#123;    int x,y,z;&#125;;\r\n那么第一是定义默认赋值顺序:\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;&#125;;\r\n那么就可以保证不管如何赋值的顺序一定是x,y,z当然现在C++的默认顺序是变量名给出的顺序，一般情况下不会出错，相当于上了一层保险。\r\n但是想要在结构体内直接使用运算符重载这是必须的。\r\n接下来记录比较符号(&lt;,&gt;,=等)的运算符重载\r\n\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;&#125;;\r\n那么上面的小于号例子就是将x的大小作为正常的&lt;比较对象。如果要改变规则很简单比如想让大根堆变为小根堆只需要将符号的方向改变也就是将即可。\r\n那么接下来是对运算符的重载\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;    inline Example operator + (Example&amp; r)&#123;        x=x+r.x;y=y+r.y;z=z+r.z;        return Example(x,y,z);    &#125;&#125;;\r\n与指针的方法相比，这种方式显然更好理解，所以将这种方式记录下来。其他的运算符同理\r\n最后是赋值运算符=的运算符重载\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;    inline Example operator + (Example&amp; r)&#123;        x=x+r.x;y=y+r.y;z=z+r.z;        return Example(x,y,z);    &#125;    inline Example operator = (Example&amp; r)&#123;        x=r.x;y=r.y;z=r.z;        return *this;    &#125;&#125;;\r\n由于赋值运算符的特殊性，这样子的方法更加稳健。\r\n结构体外的重构\r\n这里沿用上面struct的设定\r\n那么重载就变成了这样:\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;&#125;;inline Example operator + (const Example&amp; a,const Example&amp; b)&#123;    return Example(a.x+b.x,a.y+b.y,a.z+b.z);&#125;inline bool operator &lt;(const Example&amp; a,const Example&amp; b)&#123;    if (a.x==b.x)         if (a.y==b.y) return a.z&lt;b.z;        else return a.y&lt;b.y;    return a.x&lt;b.x;&#125;\r\n那么结构体外就可以将=和+，-视为一样的进行操作了。\r\n个人更加喜欢结构体外的重构，含义更加明了方便理解可以减少出错。\r\n那么基础性的运算符重载部分就这样结束啦！\r\n\r\n\r\n","categories":["学习"],"tags":["C++","结构体","零碎知识点"]},{"title":"20251001小记","url":"/2025/10/01/20251001%E5%B0%8F%E8%AE%B0/","content":"祝大家双节快乐！\r\n和九月告别，和十月初见。由于上次摔车腿伤逐渐恢复，恢复了跑步和上肢的寝室小运动。非常感动的是中午室友回来看我了！！！！让孤寂一人在寝的我得到了极大的慰藉哈哈哈哈哈哈。出乎意料的没有放假的激动，好像就是很平常的一个早上我很平常地醒了然后一如既往地去楼下学子餐厅的麦当劳吃早饭，平平淡淡才是真嘛。\r\n\r\n总算是把烦人的大物搞定啦，这样子就没有学业上的东西干扰了，明天可以开始进行ACM的刷题了。再就是明天初中哥们就来成都啦，一定要请他们去吃地道老蹄花儿，一吃一个不吱声。虽然很晚了但好歹是没有迟到更新哈哈哈哈哈，祝我和大家都能过一个快乐的国庆！\r\n\r\n\r\n","categories":["日记"],"tags":["碎碎念"]},{"title":"20250930小记","url":"/2025/09/30/20250930%E5%B0%8F%E8%AE%B0/","content":"放国庆啦！\r\n\r\n最后一节课果然还是一点没听进去，八天小长假但是呆在学校里不回家，貌似有点惨但是也还好。昨天帮舍友哥们和嫂子抢到了紫琪姐的演唱会门票，为了未来行程提早完成了大学物理实验第二次实验，新生球队也总算是井井有条变得有生气了。膝盖距离上次摔车已经过了快一周了，好得差不多但是骑车走路的时候还是会有影响，以后还是要好好注意。上一周过了非常萎靡且摆烂的生活哈哈哈哈哈哈哈哈，明天开始好好奋斗咯！而且运动要恢复起来了，制定一下！国庆每天跑五公里！加上小项的训练，英语六级需要提上日程，ACM刷题也要恢复咯。大学物理的第二次作业DDL也近了。(ง\r\n•_•)ง\r\n\r\n\r\n","categories":["日记"],"tags":["碎碎念"]},{"title":"First Blog","url":"/2025/09/30/First-Blog/","content":"历经两天终于是搭建完成了我的BLOG！上次想搭博客还是初中的时候2019年一转眼六年过去了，初中生变成了初生大学生，实在是有些快，好像经历了很多又好像什么都没干。之后的人生一定要目标明确地努力咯，好歹是知道了想干什么。第一篇文章也不知道还要说啥，看到这篇文章的兄弟们共勉吧！然后放下两张图说不定有好心人呢\r\n\r\n\r\n\r\n微信\r\n\r\n（逃\r\n\r\n\r\n","categories":["生活"],"tags":["碎碎念"]}]