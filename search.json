[{"title":"20251001小记","url":"/2025/10/01/20251001%E5%B0%8F%E8%AE%B0/","content":"祝大家双节快乐！\r\n和九月告别，和十月初见。由于上次摔车腿伤逐渐恢复，恢复了跑步和上肢的寝室小运动。非常感动的是中午室友回来看我了！！！！让孤寂一人在寝的我得到了极大的慰藉哈哈哈哈哈哈。出乎意料的没有放假的激动，好像就是很平常的一个早上我很平常地醒了然后一如既往地去楼下学子餐厅的麦当劳吃早饭，平平淡淡才是真嘛。\r\n\r\n总算是把烦人的大物搞定啦，这样子就没有学业上的东西干扰了，明天可以开始进行ACM的刷题了。再就是明天初中哥们就来成都啦，一定要请他们去吃地道老蹄花儿，一吃一个不吱声。虽然很晚了但好歹是没有迟到更新哈哈哈哈哈，祝我和大家都能过一个快乐的国庆！\r\n\r\n\r\n","categories":["日记"],"tags":["碎碎念"]},{"title":"20250930小记","url":"/2025/09/30/20250930%E5%B0%8F%E8%AE%B0/","content":"放国庆啦！\r\n\r\n最后一节课果然还是一点没听进去，八天小长假但是呆在学校里不回家，貌似有点惨但是也还好。昨天帮舍友哥们和嫂子抢到了紫琪姐的演唱会门票，为了未来行程提早完成了大学物理实验第二次实验，新生球队也总算是井井有条变得有生气了。膝盖距离上次摔车已经过了快一周了，好得差不多但是骑车走路的时候还是会有影响，以后还是要好好注意。上一周过了非常萎靡且摆烂的生活哈哈哈哈哈哈哈哈，明天开始好好奋斗咯！而且运动要恢复起来了，制定一下！国庆每天跑五公里！加上小项的训练，英语六级需要提上日程，ACM刷题也要恢复咯。大学物理的第二次作业DDL也近了。(ง\r\n•_•)ง\r\n\r\n\r\n","categories":["日记"],"tags":["碎碎念"]},{"title":"P2375 [NOI2014] 动物园","url":"/2025/10/03/P2375-NOI2014-%E5%8A%A8%E7%89%A9%E5%9B%AD/","content":"题目大意\r\n这篇题目的描述实在是废话太多了\r\n对于N个字符串，求出从头开始到i(1 ≤ i ≤ n)结束的时候每一次前缀等于后缀的数量\r\n并且前后缀不能重合\r\n比如字符串aaaa，i=4时，就有a和aa两个前后缀符合这个特点\r\n\r\n总体思路\r\nKMP+DP\r\n先抛开前缀后缀不重叠的限制\r\nKMP可以求出到第i位时最长的一致前缀和后缀，那么考虑每一个一致的前缀和后缀\r\n不难发现这时某一个字符串拥有的数量一定是他最长一致前后缀拥有的数量+1也就是多出了最长一致前后缀本身的那一组。\r\n剩下的就很简单了，\r\n由于一致前后缀的一致前后缀一定是一致前后缀\r\n(a是aa的一致前后缀，aa是aaaa的一致前后缀，a显然是aaaa的一致前后缀)\r\n只需要在累乘的时候不断地将指针跳到KMP算法求出的前一个位置，直到小于当前长度的一半，此时DP数组的值就是当前的一致前后缀数量。\r\n细节看代码，模数较大的时候一定要开long long\r\n#include&lt;cstdio&gt;#include&lt;cstring&gt;#define int long longusing namespace std;const int mod=1000000007,N=1000005;int kmp[N],sum[N];char s[N];signed main()&#123;\tint T;scanf(&quot;%lld&quot;,&amp;T);\twhile (T--)&#123;\t\tmemset(kmp,0,sizeof(kmp));\t\tmemset(sum,0,sizeof(sum));\t\tsum[1]=1;\t\tscanf(&quot;%s&quot;,s+1);\t\tint len=strlen(s+1),j=0;\t\tfor (int i=2;i&lt;=len;i++)&#123;\t\t\twhile (j &amp;&amp; s[j+1]!=s[i]) j=kmp[j];\t\t\tif (s[j+1]==s[i]) j++;\t\t\tkmp[i]=j;sum[i]=sum[j]+1;\t\t&#125;\t\tj=0;int ans=1;\t\tfor (int i=2;i&lt;=len;i++)&#123;\t\t\twhile (j &amp;&amp; s[j+1]!=s[i]) j=kmp[j];\t\t\tif (s[j+1]==s[i]) j++;\t\t\twhile (i&lt;(j&lt;&lt;1)) j=kmp[j];\t\t\tans=(ans*(sum[j]+1))%mod;\t\t&#125;\t\tprintf(&quot;%lld\\n&quot;,ans);\t&#125;\treturn 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","KMP","DP"]},{"title":"First Blog","url":"/2025/09/30/First-Blog/","content":"历经两天终于是搭建完成了我的BLOG！上次想搭博客还是初中的时候2019年一转眼六年过去了，初中生变成了初生大学生，实在是有些快，好像经历了很多又好像什么都没干。之后的人生一定要目标明确地努力咯，好歹是知道了想干什么。第一篇文章也不知道还要说啥，看到这篇文章的兄弟们共勉吧！然后放下两张图说不定有好心人呢\r\n\r\n\r\n\r\n微信\r\n\r\n（逃\r\n\r\n\r\n","categories":["生活"],"tags":["碎碎念"]},{"title":"P2922 [USACO08DEC] Secret Message G","url":"/2025/10/03/P2922-USACO08DEC-Secret-Message-G/","content":"题目大意：\r\n给出两组01串组，求问后面一组是前面的前缀或后缀的数量\r\n01trie树板子题，注意两串相等的情况即可\r\n\r\n#include&lt;cstdio&gt;using namespace std;const int N=50005;int n,m,tot,trie[500005][2],siz[500005],End[500005];bool M[N];inline void insert(int T,int rt=0)&#123;    for (int i=0;i&lt;T;i++)&#123;        siz[rt]++;        bool now=M[i];        if (!trie[rt][now]) trie[rt][now]=++tot;        rt=trie[rt][now];    &#125;    siz[rt]++;End[rt]++;&#125;inline int query(int T,int rt=0)&#123;    int res=0;    for (int i=0;i&lt;T;i++)&#123;        res+=End[rt];        bool now=M[i];        if (trie[rt][now]) rt=trie[rt][now];        else return res;    &#125;    return res+siz[rt];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for (int i=1;i&lt;=m;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        for (int j=0;j&lt;x;j++)&#123;            char ch=getchar();            while (ch!=&#x27;0&#x27; &amp;&amp; ch!=&#x27;1&#x27;) ch=getchar();            M[j]=ch-&#x27;0&#x27;;        &#125;        insert(x);    &#125;    for (int i=1;i&lt;=n;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        for (int j=0;j&lt;x;j++)&#123;            char ch=getchar();            while (ch!=&#x27;0&#x27; &amp;&amp; ch!=&#x27;1&#x27;) ch=getchar();            M[j]=ch-&#x27;0&#x27;;        &#125;        printf(&quot;%d\\n&quot;,query(x));    &#125;    return 0;&#125;\r\n完结撒花★,°:.☆(￣▽￣)/$:.°★ 。\r\n\r\n\r\n","categories":["学习"],"tags":["C++","trie树"]},{"title":"20251003小记","url":"/2025/10/03/20251003%E5%B0%8F%E8%AE%B0/","content":"首先是以后学习一定要注意细节！！！昨天一个代码只是因为一开始输入的时候大意了多打了一个n–，没有很好的理清关系，以为是主体部分出错导致调试了近两个半小时，非常不值当且让人心态爆炸，一定要注意以后。\r\n然后是很开心！又有一个室友昨天回来了哈哈哈哈寝室里呆着就没有那么孤独。以及昨天好久不见的初中哥们Wu同学来成都玩！srds吐槽一下绿皮计划五点半到达，但是接到人的时候已经八点了，等了非常久且肚子饿饿TAT.但是！晚上吃的火锅真的很满足哈哈哈哈哈但是大出血了当时太晚了很多烟火小店关门了只能到大店吃性价比真的一般打车回学校之后室友还没睡！并且后来和Wang同学激情电话（当然了没有在寝室里不要喷博主emm）非常快乐地就熬到了今天早上的凌晨，和室友吃了麦麦早餐之后就把他送走了（哥们旅游去了）。今天倒是平平淡淡没发生啥事，打扫了一下寝室的卫生履行一下这个”寝室长”的职责哈哈哈哈哈哈，重新开始我省钱的泡面计划哈哈哈哈哈哈，今日跑步休息一天因为膝盖的问题，明天继续。\r\n\r\n\r\n\r\n","categories":["日记"],"tags":["碎碎念"]},{"title":"P3435 [POI 2006] OKR-Periods of Words","url":"/2025/10/03/P3435-POI-2006-OKR-Periods-of-Words/","content":"题目大意\r\n题目定义了一个“最大周期”，也就是长度最大的一个符合条件的字符串前缀，原字符串是该前缀两倍的前缀。要求求出所有前缀的最大周期长度之和。（不存在最大周期即长度为0）\r\n\r\n再一次更加明白了KMP的内涵吧。对于进行到第i位而言，只要存在前缀和后缀相同，也就是kmp[i]存在，那么显然一定存在最大周期，要想周期最大，那么显然是该字符串最短后缀的前半部分，因为最短后缀的前半部分重复两遍必然构成符合条件的字符串，且因为后缀最短，此时求出的一定是最大周期，那么只要先求出kmp，再根据kmp的性质，递归求出最短后缀（其实也就是前缀）的长度就好了，最后用一个小trick，学习了一下并查集的路径压缩，就可以进一步压缩时间复杂度，大概是O(nlog*n)还是蛮优秀的复杂度\r\n#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N=1000005;int len,kmp[N];char s[N];inline int find(int j)&#123;\tif (kmp[j]) return kmp[j]=find(kmp[j]);\treturn j;&#125;int main()&#123;\tscanf(&quot;%d%s&quot;,&amp;len,s+1);\tfor (int i=2,j=0;i&lt;=len;i++)&#123;\t\twhile (j &amp;&amp; s[j+1]!=s[i]) j=kmp[j];\t\tif (s[j+1]==s[i]) j++;\t\tkmp[i]=j;\t&#125;\tlong long ans=0;\tfor (int i=2,j=2;i&lt;=len;i++,j=i)&#123;\t\tj=find(j);\t\tans+=i-j;\t&#125;\tprintf(&quot;%lld\\n&quot;,ans);\treturn 0;&#125; \r\n代码还是蛮简短明了的，再见咯，十月三号。\r\n\r\n\r\n","categories":["学习"],"tags":["C++","KMP"]},{"title":"P4735 最大异或和","url":"/2025/10/05/P4735-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/","content":"题目大意\r\n传送门(题面简洁明了)\r\n\r\n两种做法，可持久化trie树，离线+trie树前一种还没学，所以用了lowlow的第二种\r\n总体来说就是先离线排序出加入的顺序，根据询问建树，一边建树一边回答询问最终将答案按照原定顺序输出，在trie树上维护经过此点的最大区间下标即可，这样就可以判断是否在给出区间的左边界之后了。trie树建树就是常规的01trie前缀和建树转化区间求前缀的思路。\r\n非常重要！以后在出现函数的时候不要想着玩类似++cnt或者cnt++的把戏，非常容易出错！多打一行代码不会死。\r\n下面上代码\r\n#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#include&lt;algorithm&gt;using namespace std;const int LEN=6000005,N=600005;int n,m,tot=1,cnt,a[N],ans[N],tr[LEN][2],sec[LEN][2];struct XOR&#123;    int l,r,x,now,id;    XOR()&#123;&#125;    XOR(int L,int R,int X,int NOW,int ID): l(L),r(R),x(X),now(NOW),id(ID)&#123;&#125;&#125;b[N];inline int read()&#123;    int x=0;char ch=getchar();    while (!isdigit(ch)) ch=getchar();    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    return x;&#125;inline bool cmp(XOR a,XOR b)&#123;return a.r&lt;b.r;&#125;inline void insert(int x,int loc)&#123;    for (int i=25,rt=1;~i;i--)&#123;        bool now=(x&gt;&gt;i)&amp;1;        if (!tr[rt][now]) tr[rt][now]=++tot;        sec[rt][now]=loc;        rt=tr[rt][now];    &#125;&#125;inline int query(int x,int loc)&#123;    int res=0;    for (int i=25,rt=1;~i;i--)&#123;        bool now=(x&gt;&gt;i)&amp;1;        if (tr[rt][now^1] &amp;&amp; sec[rt][now^1]&gt;=loc)&#123;            res|=1&lt;&lt;i;            rt=tr[rt][now^1];        &#125;else rt=tr[rt][now];    &#125;    return res;&#125;int main()&#123;    n=read();m=read();    for (int i=1;i&lt;=n;i++) a[i]=read();    for (int i=1;i&lt;=m;i++)&#123;        char ch=getchar();        while (ch!=&#x27;A&#x27; &amp;&amp; ch!=&#x27;Q&#x27;) ch=getchar();        if (ch==&#x27;A&#x27;) a[++n]=read();        else&#123;            int l=read(),r=read(),x=read();            cnt++;            b[cnt]=XOR(l,r,x,n,cnt);        &#125;    &#125;    for (int i=n;i;i--) a[i]^=a[i+1];    sort(b+1,b+cnt+1,cmp);    for (int i=1,ptr=1;i&lt;=cnt;i++)&#123;        while (ptr&lt;=b[i].r)&#123;            insert(a[ptr],ptr);            ptr++;        &#125;        ans[b[i].id]=query(a[b[i].now+1]^b[i].x,b[i].l);    &#125;    for (int i=1;i&lt;=cnt;i++) printf(&quot;%d\\n&quot;,ans[i]);    return 0;&#125;\r\n\r\n\r\n","categories":["学习"],"tags":["C++","trie树"]},{"title":"struct重载运算符小记","url":"/2025/10/02/struct%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B0%8F%E8%AE%B0/","content":"结构体中的重构\r\n首先定义一个结构体\r\nstruct Example&#123;    int x,y,z;&#125;;\r\n那么第一是定义默认赋值顺序:\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;&#125;;\r\n那么就可以保证不管如何赋值的顺序一定是x,y,z当然现在C++的默认顺序是变量名给出的顺序，一般情况下不会出错，相当于上了一层保险。\r\n但是想要在结构体内直接使用运算符重载这是必须的。\r\n接下来记录比较符号(&lt;,&gt;,=等)的运算符重载\r\n\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;&#125;;\r\n那么上面的小于号例子就是将x的大小作为正常的&lt;比较对象。如果要改变规则很简单比如想让大根堆变为小根堆只需要将符号的方向改变也就是将即可。\r\n那么接下来是对运算符的重载\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;    inline Example operator + (Example&amp; r)&#123;        x=x+r.x;y=y+r.y;z=z+r.z;        return Example(x,y,z);    &#125;&#125;;\r\n与指针的方法相比，这种方式显然更好理解，所以将这种方式记录下来。其他的运算符同理\r\n最后是赋值运算符=的运算符重载\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;    inline Example operator + (Example&amp; r)&#123;        x=x+r.x;y=y+r.y;z=z+r.z;        return Example(x,y,z);    &#125;    inline Example operator = (Example&amp; r)&#123;        x=r.x;y=r.y;z=r.z;        return *this;    &#125;&#125;;\r\n由于赋值运算符的特殊性，这样子的方法更加稳健。\r\n结构体外的重构\r\n这里沿用上面struct的设定\r\n那么重载就变成了这样:\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;&#125;;inline Example operator + (const Example&amp; a,const Example&amp; b)&#123;    return Example(a.x+b.x,a.y+b.y,a.z+b.z);&#125;inline bool operator &lt;(const Example&amp; a,const Example&amp; b)&#123;    if (a.x==b.x)         if (a.y==b.y) return a.z&lt;b.z;        else return a.y&lt;b.y;    return a.x&lt;b.x;&#125;\r\n那么结构体外就可以将=和+，-视为一样的进行操作了。\r\n个人更加喜欢结构体外的重构，含义更加明了方便理解可以减少出错。\r\n那么基础性的运算符重载部分就这样结束啦！\r\n\r\n\r\n","categories":["学习"],"tags":["C++","结构体","零碎知识点"]},{"title":"luoguP5283 [十二省联考 2019] 异或粽子","url":"/2025/10/02/luoguP5283-%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%83-2019-%E5%BC%82%E6%88%96%E7%B2%BD%E5%AD%90/","content":"题目大意\r\n给出n个数的数列，要求找到k个组合[l,r]使这k个组合各个区间的异或后的和最大。\r\n\r\n整体思路\r\n首先鸽一下持久化trie树的做法，咳咳这个以后再说.本文介绍的是另一种实现简单一点的做法\r\n首先审题发现0 ≤ ai ≤ 4294967295，那么显然int的范围不够，千万不能因为细节丢分。\r\n那么首先根据题目中区间的设定和异或的性质很容易想到前缀”和”的想法。那么区间的异或值就可以O(1)求解了也就是sl − 1 ⊕ sr\r\n观察后可以发现一共有n2对组合，显然不能直接枚举，根据异或联想到01trie树可以log时间内解决区间第k大异或值的问题，那么问题就变成了:\r\n对于s0 − sn,构建一颗01trie树，并且先求出对于每一个si(0 ≤ i ≤ n)来说最优的sj，加入大根堆，这样出来的一定是第一大值，后续对于每次求出的最大值将对于该si来说的下一大值加入大根堆，这个贪心的思路可以保证每次取出的一定是当前最大值，并且由于01trie树的性质，每次取出的一定是不同的数列，除非i, j颠倒。\r\n那么对于i, j颠倒很好处理，显然如果i, j在答案队列中，j, i一定在答案中，那么只需要将原题中的k翻倍，这样选出来一定是完整的两对i, j，最后将ans折半输出即可，对于i = j的情况显然自己与自己的异或和是0，显然对答案不会有贡献。\r\n一个小坑\r\n博主在写trie树的时候总是容易忘记trie树的根是一个虚根，是无意义的，所以如果root = 1的话，记得trie树编号要从2开始！调了蛮久的。以及因为懒，直接define int long long\r\n了Emmmmm好像常数会大所以打了快读\r\n代码\r\n#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#define int long longusing namespace std;const int N=500005,TR=20000005;int n,k,tot=1,siz[TR],tr[TR][2],a[N];struct XOR&#123;    int id,rk,w;    XOR()&#123;&#125;    XOR(int x,int y,int z): id(x),rk(y),w(z)&#123;&#125;&#125;;inline bool operator &lt; (const XOR&amp; a,const XOR&amp; b)&#123;return a.w&lt;b.w;&#125;priority_queue&lt;XOR&gt; s;inline int read()&#123;    int x=0;char ch=getchar();    while (!isdigit(ch)) ch=getchar();    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    return x;&#125;inline void insert(int x,int rt=1)&#123;    siz[rt]++;    for (int i=31;~i;i--)&#123;        int now=(x&gt;&gt;i)&amp;1;        if (!tr[rt][now]) tr[rt][now]=++tot;        rt=tr[rt][now];        siz[rt]++;    &#125;&#125;inline int query(int x,int rk,int rt=1)&#123;    int res=0;    for (int i=31;~i;i--)&#123;        int now=(x&gt;&gt;i)&amp;1;        if (tr[rt][now^1])            if (rk&lt;=siz[tr[rt][now^1]])&#123;                res|=1ll&lt;&lt;i;                rt=tr[rt][now^1];            &#125;else&#123;                rk-=siz[tr[rt][now^1]];                rt=tr[rt][now];            &#125;        else rt=tr[rt][now];    &#125;    return res;&#125;signed main()&#123;    n=read();k=read()&lt;&lt;1;    insert(0);    for (int i=1;i&lt;=n;i++)&#123;        int x=read();        a[i]=a[i-1]^x;        insert(a[i]);    &#125;    for (int i=0;i&lt;=n;i++) s.push(XOR(i,1,query(a[i],1)));    int ans=0;    while (k--)&#123;        XOR now=s.top();s.pop();ans+=now.w;        if (now.rk&lt;n) s.push(XOR(now.id,now.rk+1,query(a[now.id],now.rk+1)));    &#125;    printf(&quot;%lld\\n&quot;,ans&gt;&gt;1);    return 0;&#125;\r\n完结撒花\r\n\r\n\r\n","categories":["学习"],"tags":["C++","trie树","luogu","STL"]}]