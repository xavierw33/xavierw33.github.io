[{"title":"20250930小记","url":"/2025/09/30/20250930%E5%B0%8F%E8%AE%B0/","content":"放国庆啦！\r\n\r\n最后一节课果然还是一点没听进去，八天小长假但是呆在学校里不回家，貌似有点惨但是也还好。昨天帮舍友哥们和嫂子抢到了紫琪姐的演唱会门票，为了未来行程提早完成了大学物理实验第二次实验，新生球队也总算是井井有条变得有生气了。膝盖距离上次摔车已经过了快一周了，好得差不多但是骑车走路的时候还是会有影响，以后还是要好好注意。上一周过了非常萎靡且摆烂的生活哈哈哈哈哈哈哈哈，明天开始好好奋斗咯！而且运动要恢复起来了，制定一下！国庆每天跑五公里！加上小项的训练，英语六级需要提上日程，ACM刷题也要恢复咯。大学物理的第二次作业DDL也近了。(ง\r\n•_•)ง\r\n\r\n\r\n","categories":["日记"],"tags":["碎碎念"]},{"title":"20251001小记","url":"/2025/10/01/20251001%E5%B0%8F%E8%AE%B0/","content":"祝大家双节快乐！\r\n和九月告别，和十月初见。由于上次摔车腿伤逐渐恢复，恢复了跑步和上肢的寝室小运动。非常感动的是中午室友回来看我了！！！！让孤寂一人在寝的我得到了极大的慰藉哈哈哈哈哈哈。出乎意料的没有放假的激动，好像就是很平常的一个早上我很平常地醒了然后一如既往地去楼下学子餐厅的麦当劳吃早饭，平平淡淡才是真嘛。\r\n\r\n总算是把烦人的大物搞定啦，这样子就没有学业上的东西干扰了，明天可以开始进行ACM的刷题了。再就是明天初中哥们就来成都啦，一定要请他们去吃地道老蹄花儿，一吃一个不吱声。虽然很晚了但好歹是没有迟到更新哈哈哈哈哈，祝我和大家都能过一个快乐的国庆！\r\n\r\n\r\n","categories":["日记"],"tags":["碎碎念"]},{"title":"luoguP5283 [十二省联考 2019] 异或粽子","url":"/2025/10/02/luoguP5283-%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%83-2019-%E5%BC%82%E6%88%96%E7%B2%BD%E5%AD%90/","content":"题目大意\r\n给出n个数的数列，要求找到k个组合[l,r]使这k个组合各个区间的异或后的和最大。\r\n\r\n整体思路\r\n首先鸽一下持久化trie树的做法，咳咳这个以后再说.本文介绍的是另一种实现简单一点的做法\r\n首先审题发现0 ≤ ai ≤ 4294967295，那么显然int的范围不够，千万不能因为细节丢分。\r\n那么首先根据题目中区间的设定和异或的性质很容易想到前缀”和”的想法。那么区间的异或值就可以O(1)求解了也就是sl − 1 ⊕ sr\r\n观察后可以发现一共有n2对组合，显然不能直接枚举，根据异或联想到01trie树可以log时间内解决区间第k大异或值的问题，那么问题就变成了:\r\n对于s0 − sn,构建一颗01trie树，并且先求出对于每一个si(0 ≤ i ≤ n)来说最优的sj，加入大根堆，这样出来的一定是第一大值，后续对于每次求出的最大值将对于该si来说的下一大值加入大根堆，这个贪心的思路可以保证每次取出的一定是当前最大值，并且由于01trie树的性质，每次取出的一定是不同的数列，除非i, j颠倒。\r\n那么对于i, j颠倒很好处理，显然如果i, j在答案队列中，j, i一定在答案中，那么只需要将原题中的k翻倍，这样选出来一定是完整的两对i, j，最后将ans折半输出即可，对于i = j的情况显然自己与自己的异或和是0，显然对答案不会有贡献。\r\n一个小坑\r\n博主在写trie树的时候总是容易忘记trie树的根是一个虚根，是无意义的，所以如果root = 1的话，记得trie树编号要从2开始！调了蛮久的。以及因为懒，直接define int long long\r\n了Emmmmm好像常数会大所以打了快读\r\n代码\r\n#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;ctype.h&gt;#define int long longusing namespace std;const int N=500005,TR=20000005;int n,k,tot=1,siz[TR],tr[TR][2],a[N];struct XOR&#123;    int id,rk,w;    XOR()&#123;&#125;    XOR(int x,int y,int z): id(x),rk(y),w(z)&#123;&#125;&#125;;inline bool operator &lt; (const XOR&amp; a,const XOR&amp; b)&#123;return a.w&lt;b.w;&#125;priority_queue&lt;XOR&gt; s;inline int read()&#123;    int x=0;char ch=getchar();    while (!isdigit(ch)) ch=getchar();    while (isdigit(ch))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch&amp;15);        ch=getchar();    &#125;    return x;&#125;inline void insert(int x,int rt=1)&#123;    siz[rt]++;    for (int i=31;~i;i--)&#123;        int now=(x&gt;&gt;i)&amp;1;        if (!tr[rt][now]) tr[rt][now]=++tot;        rt=tr[rt][now];        siz[rt]++;    &#125;&#125;inline int query(int x,int rk,int rt=1)&#123;    int res=0;    for (int i=31;~i;i--)&#123;        int now=(x&gt;&gt;i)&amp;1;        if (tr[rt][now^1])            if (rk&lt;=siz[tr[rt][now^1]])&#123;                res|=1ll&lt;&lt;i;                rt=tr[rt][now^1];            &#125;else&#123;                rk-=siz[tr[rt][now^1]];                rt=tr[rt][now];            &#125;        else rt=tr[rt][now];    &#125;    return res;&#125;signed main()&#123;    n=read();k=read()&lt;&lt;1;    insert(0);    for (int i=1;i&lt;=n;i++)&#123;        int x=read();        a[i]=a[i-1]^x;        insert(a[i]);    &#125;    for (int i=0;i&lt;=n;i++) s.push(XOR(i,1,query(a[i],1)));    int ans=0;    while (k--)&#123;        XOR now=s.top();s.pop();ans+=now.w;        if (now.rk&lt;n) s.push(XOR(now.id,now.rk+1,query(a[now.id],now.rk+1)));    &#125;    printf(&quot;%lld\\n&quot;,ans&gt;&gt;1);    return 0;&#125;\r\n完结撒花\r\n\r\n\r\n","categories":["学习"],"tags":["C++","luogu","trie树","STL"]},{"title":"First Blog","url":"/2025/09/30/First-Blog/","content":"历经两天终于是搭建完成了我的BLOG！上次想搭博客还是初中的时候2019年一转眼六年过去了，初中生变成了初生大学生，实在是有些快，好像经历了很多又好像什么都没干。之后的人生一定要目标明确地努力咯，好歹是知道了想干什么。第一篇文章也不知道还要说啥，看到这篇文章的兄弟们共勉吧！然后放下两张图说不定有好心人呢\r\n\r\n\r\n\r\n微信\r\n\r\n（逃\r\n\r\n\r\n","categories":["生活"],"tags":["碎碎念"]},{"title":"struct重载运算符小记","url":"/2025/10/02/struct%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B0%8F%E8%AE%B0/","content":"结构体中的重构\r\n首先定义一个结构体\r\nstruct Example&#123;    int x,y,z;&#125;;\r\n那么第一是定义默认赋值顺序:\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;&#125;;\r\n那么就可以保证不管如何赋值的顺序一定是x,y,z当然现在C++的默认顺序是变量名给出的顺序，一般情况下不会出错，相当于上了一层保险。\r\n但是想要在结构体内直接使用运算符重载这是必须的。\r\n接下来记录比较符号(&lt;,&gt;,=等)的运算符重载\r\n\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;&#125;;\r\n那么上面的小于号例子就是将x的大小作为正常的&lt;比较对象。如果要改变规则很简单比如想让大根堆变为小根堆只需要将符号的方向改变也就是将即可。\r\n那么接下来是对运算符的重载\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;    inline Example operator + (Example&amp; r)&#123;        x=x+r.x;y=y+r.y;z=z+r.z;        return Example(x,y,z);    &#125;&#125;;\r\n与指针的方法相比，这种方式显然更好理解，所以将这种方式记录下来。其他的运算符同理\r\n最后是赋值运算符=的运算符重载\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;    inline bool operator &lt; (const Example now) const&#123;return x&lt;now.x;&#125;    inline Example operator + (Example&amp; r)&#123;        x=x+r.x;y=y+r.y;z=z+r.z;        return Example(x,y,z);    &#125;    inline Example operator = (Example&amp; r)&#123;        x=r.x;y=r.y;z=r.z;        return *this;    &#125;&#125;;\r\n由于赋值运算符的特殊性，这样子的方法更加稳健。\r\n结构体外的重构\r\n这里沿用上面struct的设定\r\n那么重载就变成了这样:\r\nstruct Example&#123;    int x,y,z;    Example()&#123;&#125;    Example(int _x,int _y,int _z) :x(_x),y(_y),z(_z)&#123;&#125;&#125;;inline Example operator + (const Example&amp; a,const Example&amp; b)&#123;    return Example(a.x+b.x,a.y+b.y,a.z+b.z);&#125;inline bool operator &lt;(const Example&amp; a,const Example&amp; b)&#123;    if (a.x==b.x)         if (a.y==b.y) return a.z&lt;b.z;        else return a.y&lt;b.y;    return a.x&lt;b.x;&#125;\r\n那么结构体外就可以将=和+，-视为一样的进行操作了。\r\n个人更加喜欢结构体外的重构，含义更加明了方便理解可以减少出错。\r\n那么基础性的运算符重载部分就这样结束啦！\r\n\r\n\r\n","categories":["学习"],"tags":["C++","结构体","零碎知识点"]},{"title":"P2922 [USACO08DEC] Secret Message G","url":"/2025/10/03/P2922-USACO08DEC-Secret-Message-G/","content":"题目大意：\r\n给出两组01串组，求问后面一组是前面的前缀或后缀的数量\r\n01trie树板子题，注意两串相等的情况即可\r\n\r\n#include&lt;cstdio&gt;using namespace std;const int N=50005;int n,m,tot,trie[500005][2],siz[500005],End[500005];bool M[N];inline void insert(int T,int rt=0)&#123;    for (int i=0;i&lt;T;i++)&#123;        siz[rt]++;        bool now=M[i];        if (!trie[rt][now]) trie[rt][now]=++tot;        rt=trie[rt][now];    &#125;    siz[rt]++;End[rt]++;&#125;inline int query(int T,int rt=0)&#123;    int res=0;    for (int i=0;i&lt;T;i++)&#123;        res+=End[rt];        bool now=M[i];        if (trie[rt][now]) rt=trie[rt][now];        else return res;    &#125;    return res+siz[rt];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for (int i=1;i&lt;=m;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        for (int j=0;j&lt;x;j++)&#123;            char ch=getchar();            while (ch!=&#x27;0&#x27; &amp;&amp; ch!=&#x27;1&#x27;) ch=getchar();            M[j]=ch-&#x27;0&#x27;;        &#125;        insert(x);    &#125;    for (int i=1;i&lt;=n;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        for (int j=0;j&lt;x;j++)&#123;            char ch=getchar();            while (ch!=&#x27;0&#x27; &amp;&amp; ch!=&#x27;1&#x27;) ch=getchar();            M[j]=ch-&#x27;0&#x27;;        &#125;        printf(&quot;%d\\n&quot;,query(x));    &#125;    return 0;&#125;\r\n完结撒花★,°:.☆(￣▽￣)/$:.°★ 。\r\n\r\n\r\n","categories":["学习"],"tags":["C++","trie树"]}]